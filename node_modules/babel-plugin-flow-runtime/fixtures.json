[
  [
    "bugs/100-typed-object-spread",
    "type A = {a: number};\ntype B = {b: string};\n\ntype C = {...A, ...B};"
  ],
  [
    "bugs/123-extend-interface",
    "interface B {\n  (): string;\n}\n\ninterface A extends B {\n  prop: number;\n}\n\nlet a: A;\n\nlet val = function() {};\nval.prop = 1;\n\n// assignment 1\na = val;\n\n// assignment 2\na = { prop: 1 };"
  ],
  [
    "bugs/135-quoted-property-keys",
    "type ODataAST = {\n'$path'?: $path,\n'$select'?: $select,\n'$expand'?: $expand,\n'$filter'?: $filter,\n'$orderby'?: $orderby,\n'$callback'?: string,\n'$format'?: string,\n'$search'?: string,\n'$count'?: boolean,\n'$skip'?: number,\n'$top'?: number\n}"
  ],
  [
    "bugs/137-support-$Values",
    "type V = {\na: 123,\nb: true,\nc: null\n}\n\ntype C = $Values<V>;"
  ],
  [
    "bugs/14-exportDefaultArrowFunction",
    "export default (): string => \"hello world\";"
  ],
  [
    "bugs/14-exportDefaultClassNoName",
    "export default class {\na: string\n}"
  ],
  [
    "bugs/14-exportDefaultFunctionNoName",
    "export default function (a: number, b:number): number {\nreturn a + b;\n}"
  ],
  [
    "bugs/140-reexport-flow-type",
    "export type {Foo} from './c';"
  ],
  [
    "bugs/141-symbol-type",
    "type A = Symbol;"
  ],
  [
    "bugs/159-quoted-interface-method-names",
    "interface A {\n  \"a\"(): number;\n  \"b\"(): string;\n}"
  ],
  [
    "bugs/159-quoted-property-names-in-object-literal",
    "type A = {\"a\": string, \"b\": string};"
  ],
  [
    "bugs/24-allow-import-star-react",
    "import * as R from 'react';\n\ntype Props = {\nx: number;\ny: number;\n};\n\nclass Point extends R.Component {\nprops: Props;\nrender() {\n  return <div>{this.props.x} : {this.props.y}</div>;\n}\n}"
  ],
  [
    "bugs/24-allow-import-star",
    "import * as Foo from 'foo';"
  ],
  [
    "bugs/28-decorate-with-export-default",
    "export default function test(id: number): number {\nreturn id;\n}"
  ],
  [
    "bugs/38-intersection-object",
    "type Demo = {key: string} & {value: number};\n({key: \"foo\", value: 123}: Demo);"
  ],
  [
    "bugs/46-static-properties",
    "declare class Error {\nstatic (message?:string):Error;\nmessage: string;\nstatic captureStackTrace?: (target: Object, constructor?: Function) => void;\n}"
  ],
  [
    "bugs/47-arguments-hoisting",
    "type Person = {\nname: string\n};\n\nlet sayHello = ({ name } : Person) => {\nsayHello(name);\n}\n\nsayHello({ name: \"Kermit\" });"
  ],
  [
    "bugs/49-invalid-transform",
    "type Demo = {\nname: string,\ntype: string\n};\n\nconst task = 123;\n\nexport { task };"
  ],
  [
    "bugs/56-indexer-no-identifier",
    "type Animal = {};\n\ntype AnimalID = string;\n\ntype AnimalMap = {\n[AnimalID]: Animal;\n};"
  ],
  [
    "bugs/65-arrow-function-name",
    "const fn = (a: string): string => a;"
  ],
  [
    "bugs/67-async-destructuring-with-multiple",
    "type Person = {\nname: string\n};\n\nlet sayHello = async (a, { name } : Person, {name: nom}: Person = {name: 'bob'}, extra = nom) => {\nsayHello(name);\n}\n\nsayHello({ name: \"Kermit\" });"
  ],
  [
    "bugs/67-async-destructuring",
    "type Person = {\nname: string\n};\n\nlet sayHello = async ({ name } : Person) => {\nsayHello(name);\n}\n\nsayHello({ name: \"Kermit\" });"
  ],
  [
    "bugs/72-generators",
    "type Options = {};\n\nexport const makeApiCallSaga = (opts: Options) => {\nreturn function* apiCallWatcherSaga (): Generator<*, void, *> {\n};\n};"
  ],
  [
    "bugs/77-generator-transform",
    "function* someGenerator(): any {\n  yield 12;\n  yield 42;\n}\n\nfor (const it of someGenerator()) {\n  console.log(it);\n}"
  ],
  [
    "bugs/78-support-$Exact",
    "type Demo = $Exact<{\na: 123\n}>"
  ],
  [
    "bugs/constTypeCast",
    "for (const prop: any of []) {\n  (prop: any);\n}"
  ],
  [
    "bugs/generatorFunctions",
    "/* @flow */\n\nexport default function demo <G> () {\nfunction* gen (): G {\n  yield value;\n}\n}"
  ],
  [
    "bugs/missingNode",
    "/* @flow */\nfunction* oneTwoThree (): Iterable<number> {\nyield 1;\n}"
  ],
  [
    "bugs/propertyValueExpectedStringGotNull",
    "/* @flow */\n\nclass Demo {\n'test': boolean;\n}"
  ],
  [
    "bugs/stringPropertyKeys",
    "/* @flow */\n\nclass Demo {\n'test': boolean;\n}"
  ],
  [
    "bugs/tdzExportType",
    "function demo (): Thing {\n  return \"ok\";\n}\n\nexport type Thing = string;"
  ],
  [
    "bugs/tdzFunction",
    "function demo (): Thing {\n  return \"ok\";\n}\n\nexport type Thing = string;"
  ],
  [
    "importsExports/importClashName",
    "import t from \"babel-types\";\ntype Demo = number;"
  ],
  [
    "importsExports/importFlowRuntime",
    "import types from \"flow-runtime\";\ntype Demo = number;"
  ],
  [
    "importsExports/importFlowRuntimeReify",
    "import rt, { reify } from \"flow-runtime\";\nimport type { Type } from \"flow-runtime\";\ntype Demo = number;\nconsole.log((reify: Type<Demo>));"
  ],
  [
    "importsExports/importFlowRuntimeReifyNoDefault",
    "import { reify } from \"flow-runtime\";\nimport type { Type } from \"flow-runtime\";\ntype Demo = number;\nconsole.log((reify: Type<Demo>));"
  ],
  [
    "importsExports/shorthandImportType",
    "import { type Demo } from './simplestExportType';\n\ntype Local = number;\n\ntype Item = {\n  local: Local;\n  value: Demo;\n};"
  ],
  [
    "importsExports/simplestExportType",
    "export type Demo = string;"
  ],
  [
    "importsExports/simplestImportType",
    "import type { Demo } from './simplestExportType';\n\ntype Local = number;\n\ntype Item = {\n  local: Local;\n  value: Demo;\n};"
  ],
  [
    "patternMatching/arrayPatternWithRest",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  ([input]: string[]) => input.toUpperCase(),\n  (...items: string[]) => items.length,\n  _ => _\n);"
  ],
  [
    "patternMatching/mixedMultipleRestPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input,\n  (...input: boolean[]) => input,\n  (foo: string, ...extra: number[]) => extra.length > 1,\n  _ => _\n);"
  ],
  [
    "patternMatching/mixedPositionMultipleRestMatch",
    "import t from \"flow-runtime\";\nconsole.log(t.match(\"foo\", \"bar\", [\n  (input: string) => input,\n  (foo: string, bar: number, ...input: boolean[]) => input,\n  (foo: string, ...extra: number[]) => foo,\n  (foo: string, bar: string, baz: string, qux: string) => foo,\n  _ => _\n]));"
  ],
  [
    "patternMatching/mixedPositionMultipleRestPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input,\n  (foo: string, bar: number, ...input: boolean[]) => input,\n  (foo: string, ...extra: number[]) => foo,\n  (foo: string, bar: string, baz: string, qux: string) => foo,\n  _ => _\n);"
  ],
  [
    "patternMatching/mixedRestMatch",
    "import t from \"flow-runtime\";\nconsole.log(t.match(\"foo\", [\n  (input: string) => input,\n  (...input: boolean[]) => input,\n  _ => _\n]));"
  ],
  [
    "patternMatching/mixedRestPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input,\n  (...input: boolean[]) => input,\n  _ => _\n);"
  ],
  [
    "patternMatching/patternWithClashingArgs",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (c: string, b: string) => {\n    const d = c + b;\n    return d.toUpperCase();\n  },\n  (a: boolean, c: number) => {\n    const b = c > 0;\n    return a && b ? \"YES\" : \"NO\";\n  },\n  (a: number, b: number, c: number) => {\n    return a + b + c;\n  },\n  _ => _\n);"
  ],
  [
    "patternMatching/patternWithClashingVars",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (a: string, b: string) => {\n    const c = a + b;\n    return c.toUpperCase();\n  },\n  (a: boolean, c: number) => {\n    const b = c > 0;\n    return a && b ? \"YES\" : \"NO\";\n  },\n  (a: number, b: number, c: number) => {\n    return a + b + c;\n  },\n  _ => _\n);"
  ],
  [
    "patternMatching/patternWithMultipleArgs",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input.toUpperCase(),\n  (input: boolean, b: number) => input && b > 0 ? \"YES\" : \"NO\",\n  _ => _\n);"
  ],
  [
    "patternMatching/patternWithUnion",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input.toUpperCase(),\n  (input: boolean | number) => input ? \"YES\" : \"NO\",\n  _ => _\n);"
  ],
  [
    "patternMatching/simpleArrayPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  ([input]: string[]) => input.toUpperCase(),\n  _ => _\n);"
  ],
  [
    "patternMatching/simpleMatch",
    "import t from \"flow-runtime\";\nconsole.log(t.match(\n  \"foo\",\n  [\n    (input: string) => input.toUpperCase(),\n    (input: boolean) => input ? \"YES\" : \"NO\",\n    _ => _\n  ]\n));"
  ],
  [
    "patternMatching/simpleMatchNoDefault",
    "import t from \"flow-runtime\";\nconsole.log(t.match(\n  \"foo\",\n  [\n    (input: null) => \"NULL\",\n    (input: string) => input.toUpperCase(),\n    (input: boolean) => input ? \"YES\" : \"NO\"\n  ]\n));"
  ],
  [
    "patternMatching/simpleObjectPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  ({input}: Object) => input.toUpperCase(),\n  _ => _\n);"
  ],
  [
    "patternMatching/simplePattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: string) => input.toUpperCase(),\n  (input: boolean) => input ? \"YES\" : \"NO\",\n  _ => _\n);"
  ],
  [
    "patternMatching/simplePatternNoDefault",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (input: null) => \"NULL\",\n  (input: string) => input.toUpperCase(),\n  (input: boolean) => input ? \"YES\" : \"NO\",\n);"
  ],
  [
    "patternMatching/simplestRestPattern",
    "import t from \"flow-runtime\";\nconst pattern = t.pattern(\n  (...input: string[]) => true,\n  (...input: boolean[]) => false,\n  _ => _\n);"
  ],
  [
    "pragma/pragmaIgnore",
    "/* @flow */\n/* @flow-runtime ignore */\n\nconst Demo = 123;"
  ],
  [
    "pragma/pragmaOptInStrict",
    "/* @flow */\n/* @flow-runtime */\n\nconst Demo = 123;"
  ],
  [
    "pragma/pragmaWarn",
    "/* @flow */\n/* @flow-runtime warn */\n\ntype Demo = 123;\n\n(\"nope\": Demo);"
  ],
  [
    "pragma/pragmaWarnAndDecorate",
    "/* @flow */\n/* @flow-runtime warn, annotate */\n\ntype Demo = 123;\n\n(\"nope\": Demo);\n\nconst demo = ([foo]: string[]): string => foo;"
  ],
  [
    "pragma/pragmaWarnClass",
    "/* @flow */\n/* @flow-runtime warn */\n\nclass A {\nx: boolean = false;\n}"
  ],
  [
    "pragma/suppressComment",
    "/* @flow */\n\nconst demo = (): string => \"hello world\";\n\n// $FlowFixMe\nconst demo2 = (): string => \"hello world\";"
  ],
  [
    "pragma/suppressCommentClass",
    "/* @flow */\n\ntype Demo = false;\n\nclass Thing {\n// $FlowFixMe\na: string;\n\nb: Demo;\n}"
  ],
  [
    "pragma/suppressCommentIfBlock",
    "/* @flow */\n\ntype Demo = false;\n\n// $FlowFixMe\nif (true) {\nconsole.log((false: true));\n}\nelse {\nconsole.log((true: Demo));\n}"
  ],
  [
    "pragma/suppressType",
    "/* @flow */\n\ntype Demo = 123;\n\nlet oneTwoThree: Demo = 123;\n\n(oneTwoThree: $FlowFixMe);\n\noneTwoThree = 456;\nconsole.log(123, '=', oneTwoThree);"
  ],
  [
    "specialForms/classAnnotation",
    "class User {}\n\nfunction demo (model: Class<User>) {\n\n}"
  ],
  [
    "typeAliases/arrays/arrayOfArrays",
    "type Demo = Array<Array<number>>;"
  ],
  [
    "typeAliases/arrays/numberArray",
    "type Demo = number[];"
  ],
  [
    "typeAliases/builtins/date",
    "type Demo = Date;"
  ],
  [
    "typeAliases/builtins/map",
    "type Demo = Map<number, string>;"
  ],
  [
    "typeAliases/defaultTypeParameters",
    "type Demo<T=number> = {\n  x: T;\n};"
  ],
  [
    "typeAliases/functions/functionWithAnonymousParam",
    "type Demo = (string) => string;"
  ],
  [
    "typeAliases/functions/functionWithMultipleOptionalParams",
    "type Demo = (a?: string, b?: number) => string;"
  ],
  [
    "typeAliases/functions/functionWithMultipleParams",
    "type Demo = (a: string, b: number) => string;"
  ],
  [
    "typeAliases/functions/functionWithOptionalParam",
    "type Demo = (a?: string) => string;"
  ],
  [
    "typeAliases/functions/functionWithParam",
    "type Demo = (a: string) => string;"
  ],
  [
    "typeAliases/functions/functionWithRestParam",
    "type Demo = (...a: string[]) => string;"
  ],
  [
    "typeAliases/functions/functionWithTrailingRestParam",
    "type Demo = (a: number, ...b: string[]) => string;"
  ],
  [
    "typeAliases/functions/simplestBoundTypeParameterizedFunction",
    "type Demo = <T: string> () => T;"
  ],
  [
    "typeAliases/functions/simplestFunction",
    "type Demo = () => void;"
  ],
  [
    "typeAliases/functions/simplestTypeParameterizedFunction",
    "type Demo = <T> () => T;"
  ],
  [
    "typeAliases/functions/typeParameterizedFunction",
    "type Demo = <T> (a: T) => T;"
  ],
  [
    "typeAliases/hoistedNestedType",
    "type B = {a: A};\ntype A = number;"
  ],
  [
    "typeAliases/hoistedType",
    "type B = A;\ntype A = string;"
  ],
  [
    "typeAliases/multualRecursion",
    "type B = {a: A};\ntype A = {b: B};"
  ],
  [
    "typeAliases/mutualRecursion",
    "type B = {a: A};\ntype A = {b: B};"
  ],
  [
    "typeAliases/objects/objectWithMultipleCallProperties",
    "type Demo = {\n  (foo: string): string;\n  (bar: boolean): boolean;\n};"
  ],
  [
    "typeAliases/objects/objectWithMultipleIndexers",
    "type Demo = {\n  [key: string]: number;\n  [index: number]: boolean;\n};"
  ],
  [
    "typeAliases/objects/objectWithMultipleProperties",
    "type Demo = {\n  foo: string;\n  bar: number;\n  baz: number | string;\n};"
  ],
  [
    "typeAliases/objects/objectWithOptionalProperties",
    "type Tree<T> = {\n  value: T;\n  left?: Tree<T>;\n  right?: Tree<T>;\n};"
  ],
  [
    "typeAliases/objects/objectWithPropertiesCallPropertiesIndexers",
    "type Demo = {\n  (foo: string): string;\n  (bar: boolean): boolean;\n  foo: string;\n  bar: number;\n  baz: number | string;\n  [key: string]: number;\n  [index: number]: boolean;\n};"
  ],
  [
    "typeAliases/objects/personObjectWithTypeParameters",
    "type Person<A: string> = {\n  name: string;\n  surname: A;\n};"
  ],
  [
    "typeAliases/objects/simplestExactObject",
    "type Demo = {|\n  key: string;\n|};"
  ],
  [
    "typeAliases/objects/simplestObject",
    "type Demo = {\n  key: string;\n};"
  ],
  [
    "typeAliases/objects/simplestObjectCallProperty",
    "type Demo = {\n  (input: string): string;\n};"
  ],
  [
    "typeAliases/objects/simplestObjectIndexer",
    "type Demo = {\n  [key: string]: number;\n};"
  ],
  [
    "typeAliases/objects/simplestObjectWithTypeParameters",
    "type Demo<T: string> = {\n  key: T;\n};"
  ],
  [
    "typeAliases/primitives/boolean",
    "type Demo = boolean;"
  ],
  [
    "typeAliases/primitives/booleanLiteral",
    "type Demo = true;"
  ],
  [
    "typeAliases/primitives/number",
    "type Demo = number;"
  ],
  [
    "typeAliases/primitives/numericLiteral",
    "type Demo = 123;"
  ],
  [
    "typeAliases/primitives/string",
    "type Demo = string;"
  ],
  [
    "typeAliases/primitives/stringLiteral",
    "type Demo = \"foo\";"
  ],
  [
    "typeAliases/selfReferentialType",
    "type Demo = {\n  next: ? Demo;\n};"
  ],
  [
    "typeAliases/simplestParameterizedType",
    "type Demo<T> = T;"
  ],
  [
    "typeAliases/simplestTypeParameterApplication",
    "type Person<A> = {\n  name: string,\n  surname: A\n};\n\ntype PersonType = Person<string>;"
  ],
  [
    "typeAliases/tuples/tuple",
    "type Demo = [number, string];"
  ],
  [
    "typeAliases/unions/numberStringUnion",
    "type Demo = number | string;"
  ],
  [
    "typeAssertions/classes/classWithInterfaceAndConstructor",
    "interface IPoint<T> {\n  x: T;\n  y: T;\n}\nclass Point implements IPoint<number> {\n  x: number = 0;\n  y: number = 0;\n\n  constructor () {\n    console.log('created point');\n  }\n}"
  ],
  [
    "typeAssertions/classes/classWithMultipleInterfacesAndSuper",
    "interface XPoint<T> {\n  x: T;\n}\ninterface YPoint<T> {\n  y: T;\n}\n\nclass Base {}\n\nclass Point extends Base implements XPoint<number>, YPoint<number> {\n  x: number = 0;\n  y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/classWithTypeParametersAndStaticMethods",
    "class Point <T: number> {\n  x: T = 0;\n  y: T = 0;\n\n  constructor (x: T, y: T) {\n    this.x = x;\n    this.y = y;\n  }\n\n  static create (x: T, y: T): Point<T> {\n    return new Point(x, y);\n  }\n}"
  ],
  [
    "typeAssertions/classes/simplestClass",
    "class Point {\n  x: number = 0;\n  y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassNoDefaults",
    "class Point {\n  x: number;\n  y: number;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithAccessors",
    "class Point {\n  x: number = 0;\n  y: number = 0;\n\n  get foo (): boolean {\n    return true;\n  }\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithComputedProperty",
    "class Point {\n  x: number = 0;\n  y: number = 0;\n\n  [\"foo\"]: boolean;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithInterface",
    "interface IPoint<T> {\n  x: T;\n  y: T;\n}\nclass Point implements IPoint<number> {\n  x: number = 0;\n  y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithMethod",
    "class Point {\n  x: number = 0;\n  y: number = 0;\n\n  move (xDiff: number, yDiff: number): Point {\n    const point = new Point();\n    point.x = this.x + xDiff;\n    point.y = this.y + yDiff;\n    return point;\n  }\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithMethodWithDefaultArg",
    "class Point {\n  x: number = 0;\n  y: number = 0;\n\n  z (a: string = \"123\"): string {\n    return a;\n  }\n\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithMultipleInterface",
    "interface XPoint<T> {\n  x: T;\n}\ninterface YPoint<T> {\n  y: T;\n}\nclass Point implements XPoint<number>, YPoint<number> {\n  x: number = 0;\n  y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithParent",
    "class Parent {\n  x: number = 0;\n}\n\nclass Child extends Parent {\n  y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithStatics",
    "class Point {\n  x: number = 0;\n  static y: number = 0;\n}"
  ],
  [
    "typeAssertions/classes/simplestClassWithTypeParameters",
    "class Point <T: number> {\n  x: T = 0;\n  y: T = 0;\n\n  constructor (x: T, y: T) {\n    this.x = x;\n    this.y = y;\n  }\n}"
  ],
  [
    "typeAssertions/classes/thisTypeAnnotation",
    "class A {\n  b(): this {\n    return this;\n  }\n}"
  ],
  [
    "typeAssertions/classes/typeParametersWithInheritance",
    "class Point <T: number> {\n  x: T = 0;\n  y: T = 0;\n\n  constructor (x: T, y: T) {\n    this.x = x;\n    this.y = y;\n  }\n}\n\ntype Float = number;\nclass FloatPoint extends Point<Float> {\n  constructor ([x, y]: [Float, Float]) {\n    super(x, y);\n  }\n}\n\nclass FPoint<F: Float> extends Point<F> {\n  constructor ([x, y]: [F, F]) {\n    super(x, y);\n  }\n}"
  ],
  [
    "typeAssertions/functions/arrayPattern",
    "const demo = ([foo]: string[]): string => foo;"
  ],
  [
    "typeAssertions/functions/boundTypeParameter",
    "const demo = <T: string> (input: T): T => input;"
  ],
  [
    "typeAssertions/functions/defaultParam",
    "const demo = (input: string = \"Hello World\"): string => input;"
  ],
  [
    "typeAssertions/functions/delegatingGeneratorFunction",
    "function *demo (): Generator<string, void, void> {\n  yield* \"hello world\";\n}"
  ],
  [
    "typeAssertions/functions/functionReturnsPromise",
    "const demo = (): Promise<string> => Promise.resolve(\"hello world\");"
  ],
  [
    "typeAssertions/functions/multipleParameters",
    "const demo = (a: string, b: string): string => a + b;"
  ],
  [
    "typeAssertions/functions/multipleTypeParameters",
    "const demo = <K, V> (key: K, value: V): Map<K, V> => new Map([[key, value]]);"
  ],
  [
    "typeAssertions/functions/nestedAsyncFunction",
    "const demo = async (): Promise<string> => \"hello world\";"
  ],
  [
    "typeAssertions/functions/nestedFunctionWithTypeParameters",
    "const demo = <T> (input: T): () => T => (): T => input;"
  ],
  [
    "typeAssertions/functions/nextGeneratorFunction",
    "function *demo (): Generator<string, boolean, number> {\n  const result = yield* \"hello world\";\n  return result > 2 ? true : false;\n}"
  ],
  [
    "typeAssertions/functions/objectPattern",
    "const demo = ({foo}: {foo: string}): string => foo;"
  ],
  [
    "typeAssertions/functions/objectPatternLastParam",
    "const demo = (a: string, {foo}: {foo: string}): string => a + foo;"
  ],
  [
    "typeAssertions/functions/objectPatternWithDefault",
    "const demo = ({foo}: {foo: string} = {foo: \"hello world\"}): string => foo;"
  ],
  [
    "typeAssertions/functions/optionalObjectPattern",
    "const demo = ({foo}?: {foo: string}): string => foo;"
  ],
  [
    "typeAssertions/functions/optionalParam",
    "const demo = (input?: string): ? string => input;"
  ],
  [
    "typeAssertions/functions/restParams",
    "const demo = (...args: string[]): string[] => args;"
  ],
  [
    "typeAssertions/functions/returningGeneratorFunction",
    "function *demo (): Generator<string, boolean, void> {\n  yield* \"hello world\";\n  return true;\n}"
  ],
  [
    "typeAssertions/functions/simplestAsyncFunction",
    "const demo = async (): Promise<string> => \"hello world\";"
  ],
  [
    "typeAssertions/functions/simplestFunction",
    "const demo = (): string => \"hello world\";"
  ],
  [
    "typeAssertions/functions/simplestFunctionWithParam",
    "const demo = (input: string): string => input;"
  ],
  [
    "typeAssertions/functions/simplestFunctionWithTypeParameters",
    "const demo = <T> (input: T): T => input;"
  ],
  [
    "typeAssertions/functions/simplestGeneratorFunction",
    "function *demo (): Generator<string, void, void> {\n  yield \"hello world\";\n}"
  ],
  [
    "typeAssertions/modules/simplestExport",
    "export type Demo = number;"
  ],
  [
    "typeAssertions/modules/simplestImport",
    "import type {Demo} from './simplestExport';"
  ],
  [
    "typeAssertions/react/reactClassWithTypeParameters",
    "import React from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends React.Component<Props, void> {\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/react/reactImportComponent",
    "import { Component } from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends Component<Props, void> {\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/react/reactImportComponentWithAlias",
    "import { Component as C } from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends C<Props, void> {\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/react/reactImportPureComponent",
    "import { PureComponent } from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends PureComponent<Props, void> {\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/react/reactPureComponent",
    "import React from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends React.PureComponent<Props, void> {\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/react/simplestReactClass",
    "import React from \"react\";\n\ntype Props = {\n  x: number;\n  y: number;\n};\n\nclass Point extends React.Component {\n  props: Props;\n  render() {\n    return <div>{this.props.x} : {this.props.y}</div>;\n  }\n}"
  ],
  [
    "typeAssertions/tryCatch/simplestTryCatch",
    "try {\n  throw new TypeError('Intentional');\n}\ncatch (e) {\n  (e: TypeError);\n  console.log(e);\n}"
  ],
  [
    "typeAssertions/typeOf/qualifiedTypeOf",
    "const a = {b: 123} ;\nconst c: typeof a.b = 456;"
  ],
  [
    "typeAssertions/typeOf/simplestTypeOf",
    "const a = 123 ;\nconst b: typeof a = 456;"
  ],
  [
    "typeAssertions/typeOf/typeQualifiedTypeOf",
    "declare var a: {b: number};\nconst c: typeof a.b = 456;"
  ],
  [
    "typeAssertions/typecasts/inlineTypeCast",
    "const a = {\n  b: 123\n};\nfunction go() {\n  return 456;\n}\na.b = a.b + (go(): number);"
  ],
  [
    "typeAssertions/typecasts/repeatedTypeCast",
    "let a = 123;\n(a: number);\n(a: any);\na = \"hello world\";\n(a: string);"
  ],
  [
    "typeAssertions/typecasts/simplestTypeCast",
    "let a = 123;\n(a: number);"
  ],
  [
    "typeAssertions/typecasts/typeCastMemberExpression",
    "const a = {\n  b: 123\n};\n(a.b: number);"
  ],
  [
    "typeAssertions/variables/constDeclaration",
    "const demo: string = \"hello world\";"
  ],
  [
    "typeAssertions/variables/letDeclaration",
    "let demo: string = \"hello world\";"
  ],
  [
    "typeAssertions/variables/letDeclarationWithAssignment",
    "let demo: string;\ndemo = \"foo bar\";"
  ],
  [
    "typeAssertions/variables/letDeclarationWithMultipleAssignments",
    "let demo: string = \"qux\";\ndemo = \"foo bar\";\ndemo = \"hello world\";"
  ],
  [
    "typeAssertions/variables/patternDeclaration",
    "const [hello, world]: [string, string] = [\"hello\", \"world\"];"
  ],
  [
    "typeAssertions/variables/varDeclaration",
    "var demo: string = \"hello world\";"
  ],
  [
    "typeAssertions/variables/varDeclarationWithAssignment",
    "var demo: string;\ndemo = \"foo bar\";"
  ],
  [
    "typeDeclarations/classes/awaitAndPromise",
    "type IteratorResult<Yield,Return> =\n| { done: true, value?: Return }\n| { done: false, value: Yield };\n\ninterface $Iterator<+Yield,+Return,-Next> {\n  next(value?: Next): IteratorResult<Yield,Return>;\n}\ntype Iterator<+T> = $Iterator<T,void,void>;\n\ninterface $Iterable<+Yield,+Return,-Next> {\n}\ntype Iterable<+T> = $Iterable<T,void,void>;\n\ndeclare class Promise<+R> {\n  constructor(callback: (\n    resolve: (result: Promise<R> | R) => void,\n    reject:  (error: any) => void\n  ) => mixed): void;\n\n  then<U>(\n    onFulfill?: (value: R) => Promise<U> | U,\n    onReject?: (error: any) => Promise<U> | U\n  ): Promise<U>;\n\n  catch<U>(\n    onReject?: (error: any) => Promise<U> | U\n  ): Promise<R | U>;\n\n  static resolve<T>(object: Promise<T> | T): Promise<T>;\n  static reject<T>(error?: any): Promise<T>;\n  static all<T: Iterable<mixed>>(promises: T): Promise<$TupleMap<T, typeof $await>>;\n  static race<T, Elem: Promise<T> | T>(promises: Array<Elem>): Promise<T>;\n}\n\n// we use this signature when typing await expressions\ndeclare function $await<T>(p: Promise<T> | T): T;"
  ],
  [
    "typeDeclarations/classes/classWithConcreteSuper",
    "class Thing {\n  name: string;\n}\n\ndeclare class Place extends Thing {\n  url: string;\n}"
  ],
  [
    "typeDeclarations/classes/classWithSuperTypeParameters",
    "declare class Thing<T> {\n  id: T;\n  name: string;\n}\n\ndeclare class Place extends Thing<string> {\n  url: string;\n}"
  ],
  [
    "typeDeclarations/classes/classWithTypeParameters",
    "declare class Thing<T: string> {\n  name: T;\n}"
  ],
  [
    "typeDeclarations/classes/simplestClass",
    "declare class Thing {\n  name: string;\n}"
  ],
  [
    "typeDeclarations/classes/simplestClassWithSuper",
    "declare class Thing {\n  name: string;\n}\n\ndeclare class Place extends Thing {\n  url: string;\n}"
  ],
  [
    "typeDeclarations/functions/simplestFunction",
    "declare function demo (): string;"
  ],
  [
    "typeDeclarations/modules/simplestModule",
    "declare module Demo {\n  declare var foo: string;\n}"
  ],
  [
    "typeDeclarations/modules/simplestModuleExports",
    "declare module \"Demo\" {\n  declare module.exports: any;\n}"
  ],
  [
    "typeDeclarations/modules/simplestModuleWithStringName",
    "declare module \"foo-bar\" {\n  declare var foo: string;\n}"
  ],
  [
    "typeDeclarations/types/simplestType",
    "declare type Demo = string;"
  ],
  [
    "typeDeclarations/vars/simplestVar",
    "declare var demo;"
  ],
  [
    "typeDeclarations/vars/simplestVarWithAnnotation",
    "declare var demo: string;"
  ]
]
