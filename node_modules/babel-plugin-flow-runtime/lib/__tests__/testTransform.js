'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = testTransform;

var _assert = require('assert');

var _fixtures = require('./fixtures');

var _fixtures2 = _interopRequireDefault(_fixtures);

var _transform = require('../transform');

var _transform2 = _interopRequireDefault(_transform);

var _babylon = require('babylon');

var babylon = _interopRequireWildcard(_babylon);

var _babelGenerator = require('babel-generator');

var _babelGenerator2 = _interopRequireDefault(_babelGenerator);

var _babelTraverse = require('babel-traverse');

var _babelTraverse2 = _interopRequireDefault(_babelTraverse);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stripFlowTypes(program) {
  (0, _babelTraverse2.default)(program, {
    Flow: function Flow(path) {
      path.remove();
    },
    TypeCastExpression: function TypeCastExpression(path) {
      var node = path.node;

      do {
        node = node.expression;
      } while (node.type === 'TypeCastExpression');
      path.replaceWith(node);
    },
    Class: function Class(path) {
      path.node.implements = null;
    }
  });
  return program;
}

function parse(source) {
  return babylon.parse(source, {
    filename: 'unknown',
    sourceType: 'module',
    plugins: ['jsx', 'flow', 'doExpressions', 'objectRestSpread', 'decorators', 'classProperties', 'exportExtensions', 'asyncGenerators', 'functionBind', 'functionSent']
  });
}

function normalize(input) {
  return input.trim().replace(/\s+/g, ' ').replace(/\(\s+/g, '(').replace(/\s+\)/g, ')').replace(/\{\s+/g, '{\n').replace(/\s+\}/g, '\n}').replace(/\[\s+/g, '[').replace(/\s+]/g, ']').replace(/\}\s+([A-Za-z])/g, '\n}\n$1').split(';').join(';\n').trim();
}

function testTransform(input, options, expected) {
  var parsed = parse(input);
  var transformed = stripFlowTypes((0, _transform2.default)(parsed, options));
  var generated = (0, _babelGenerator2.default)(transformed).code;
  (0, _assert.equal)(normalize(generated), normalize(expected));
}