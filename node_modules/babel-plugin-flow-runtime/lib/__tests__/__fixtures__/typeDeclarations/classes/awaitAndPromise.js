"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var input = exports.input = "\n\ntype IteratorResult<Yield,Return> =\n  | { done: true, value?: Return }\n  | { done: false, value: Yield };\n\ninterface $Iterator<+Yield,+Return,-Next> {\n    next(value?: Next): IteratorResult<Yield,Return>;\n}\ntype Iterator<+T> = $Iterator<T,void,void>;\n\ninterface $Iterable<+Yield,+Return,-Next> {\n}\ntype Iterable<+T> = $Iterable<T,void,void>;\n\ndeclare class Promise<+R> {\n    constructor(callback: (\n      resolve: (result: Promise<R> | R) => void,\n      reject:  (error: any) => void\n    ) => mixed): void;\n\n    then<U>(\n      onFulfill?: (value: R) => Promise<U> | U,\n      onReject?: (error: any) => Promise<U> | U\n    ): Promise<U>;\n\n    catch<U>(\n      onReject?: (error: any) => Promise<U> | U\n    ): Promise<R | U>;\n\n    static resolve<T>(object: Promise<T> | T): Promise<T>;\n    static reject<T>(error?: any): Promise<T>;\n    static all<T: Iterable<mixed>>(promises: T): Promise<$TupleMap<T, typeof $await>>;\n    static race<T, Elem: Promise<T> | T>(promises: Array<Elem>): Promise<T>;\n}\n\n// we use this signature when typing await expressions\ndeclare function $await<T>(p: Promise<T> | T): T;\n\n\n";

var expected = exports.expected = "\n  import t from \"flow-runtime\";\n  const IteratorResult = t.type(\"IteratorResult\", IteratorResult => {\n    const Yield = IteratorResult.typeParameter(\"Yield\"),\n          Return = IteratorResult.typeParameter(\"Return\");\n    return t.union(t.object(t.property(\"done\", t.boolean(true)), t.property(\"value\", Return, true)), t.object(t.property(\"done\", t.boolean(false)), t.property(\"value\", Yield)));\n  });\n  const $Iterator = t.type(\"$Iterator\", $Iterator => {\n    const Yield = $Iterator.typeParameter(\"Yield\"),\n          Return = $Iterator.typeParameter(\"Return\"),\n          Next = $Iterator.typeParameter(\"Next\");\n    return t.object(t.property(\"next\", t.function(t.param(\"value\", Next, true), t.return(t.ref(IteratorResult, Yield, Return)))));\n  });\n  const Iterator = t.type(\"Iterator\", Iterator => {\n    const T = Iterator.typeParameter(\"T\");\n    return t.ref($Iterator, T, t.void(), t.void());\n  });\n  const $Iterable = t.type(\"$Iterable\", $Iterable => {\n    const Yield = $Iterable.typeParameter(\"Yield\"),\n          Return = $Iterable.typeParameter(\"Return\"),\n          Next = $Iterable.typeParameter(\"Next\");\n    return t.object();\n  });\n  const Iterable = t.type(\"Iterable\", Iterable => {\n    const T = Iterable.typeParameter(\"T\");\n    return t.ref($Iterable, T, t.void(), t.void());\n  });\n  t.declare(t.class(\"Promise\", _Promise => {\n    const R = _Promise.typeParameter(\"R\");\n\n    return [t.object(t.property(\"constructor\", t.function(t.param(\"callback\", t.function(t.param(\"resolve\", t.function(t.param(\"result\", t.union(t.ref(\"Promise\", R), R)), t.return(t.void()))), t.param(\"reject\", t.function(t.param(\"error\", t.any()), t.return(t.void()))), t.return(t.mixed()))), t.return(t.void()))), t.property(\"then\", t.function(_fn => {\n      const U = _fn.typeParameter(\"U\");\n\n      return [t.param(\"onFulfill\", t.function(t.param(\"value\", R), t.return(t.union(t.ref(\"Promise\", U), U))), true), t.param(\"onReject\", t.function(t.param(\"error\", t.any()), t.return(t.union(t.ref(\"Promise\", U), U))), true), t.return(t.ref(\"Promise\", U))];\n    })), t.property(\"catch\", t.function(_fn2 => {\n      const U = _fn2.typeParameter(\"U\");\n\n      return [t.param(\"onReject\", t.function(t.param(\"error\", t.any()), t.return(t.union(t.ref(\"Promise\", U), U))), true), t.return(t.ref(\"Promise\", t.union(R, U)))];\n    })), t.staticProperty(\"resolve\", t.function(_fn3 => {\n      const T = _fn3.typeParameter(\"T\");\n\n      return [t.param(\"object\", t.union(t.ref(\"Promise\", T), T)), t.return(t.ref(\"Promise\", T))];\n    })), t.staticProperty(\"reject\", t.function(_fn4 => {\n      const T = _fn4.typeParameter(\"T\");\n\n      return [t.param(\"error\", t.any(), true), t.return(t.ref(\"Promise\", T))];\n    })), t.staticProperty(\"all\", t.function(_fn5 => {\n      const T = _fn5.typeParameter(\"T\", t.ref(Iterable, t.mixed()));\n\n      return [t.param(\"promises\", T), t.return(t.ref(\"Promise\", t.$tupleMap(T, t.ref(\"$await\"))))];\n    })), t.staticProperty(\"race\", t.function(_fn6 => {\n      const T = _fn6.typeParameter(\"T\"),\n            Elem = _fn6.typeParameter(\"Elem\", t.union(t.ref(\"Promise\", T), T));\n\n      return [t.param(\"promises\", t.array(Elem)), t.return(t.ref(\"Promise\", T))];\n    })))];\n  }));\n\n  // we use this signature when typing await expressions\n\n  t.declare(\"$await\", t.function(_fn7 => {\n    const T = _fn7.typeParameter(\"T\");\n\n    return [t.param(\"p\", t.union(t.ref(\"Promise\", T), T)), t.return(T)];\n  }));\n";