{"version":3,"file":"flow-runtime.js","sources":["../src/primitiveTypes.js","../src/errorReporting/makeJSONError.js","../src/cyclic.js","../src/Validation.js","../src/errorReporting/RuntimeTypeError.js","../src/errorReporting/makeTypeError.js","../src/makeError.js","../src/compareTypes.js","../src/types/Type.js","../src/types/AnyType.js","../src/errorMessages.js","../src/getErrorMessage.js","../src/types/TupleType.js","../src/types/ArrayType.js","../src/types/BooleanLiteralType.js","../src/types/BooleanType.js","../src/types/EmptyType.js","../src/types/ExistentialType.js","../src/types/TypeParameterApplication.js","../src/typeConstraints.js","../src/types/TypeAlias.js","../src/types/TypeParameter.js","../src/types/FlowIntoType.js","../src/types/FunctionTypeRestParam.js","../src/types/FunctionTypeParam.js","../src/types/FunctionTypeReturn.js","../src/symbols.js","../src/types/FunctionType.js","../src/types/GeneratorType.js","../src/types/TypeConstructor.js","../src/types/GenericType.js","../src/invariant.js","../src/types/NullLiteralType.js","../src/types/VoidType.js","../src/types/NullableType.js","../src/types/ObjectTypeProperty.js","../src/types/ObjectTypeIndexer.js","../src/types/ObjectTypeCallProperty.js","../src/declarations/Declaration.js","../src/declarations/VarDeclaration.js","../src/declarations/TypeDeclaration.js","../src/declarations/ModuleDeclaration.js","../src/declarations/ModuleExportsDeclaration.js","../src/declarations/ClassDeclaration.js","../src/types/PartialType.js","../src/declarations/ParameterizedClassDeclaration.js","../src/declarations/ExtendsDeclaration.js","../src/types/ObjectType.js","../src/types/IntersectionType.js","../src/types/MixedType.js","../src/types/NumericLiteralType.js","../src/types/NumberType.js","../src/types/ParameterizedTypeAlias.js","../src/types/ParameterizedFunctionType.js","../src/types/RefinementType.js","../src/types/StringLiteralType.js","../src/types/StringType.js","../src/types/SymbolLiteralType.js","../src/types/SymbolType.js","../src/types/ThisType.js","../src/types/TypeBox.js","../src/types/TypeReference.js","../src/types/TypeTDZ.js","../src/types/UnionType.js","../src/registerPrimitiveTypes.js","../src/registerBuiltins.js","../src/registerTypePredicates.js","../src/TypeInferrer.js","../src/makeReactPropTypes.js","../src/errorReporting/makeWarningMessage.js","../src/makeUnion.js","../src/classDecorators.js","../src/annotateValue.js","../src/flowTypes/$DiffType.js","../src/flowTypes/$FlowFixMeType.js","../src/flowTypes/$KeysType.js","../src/flowTypes/$ObjMapiType.js","../src/flowTypes/$ObjMapType.js","../src/flowTypes/$PropertyType.js","../src/flowTypes/$ShapeType.js","../src/flowTypes/$SubType.js","../src/flowTypes/$SuperType.js","../src/flowTypes/$TupleMapType.js","../src/flowTypes/$ValuesType.js","../src/flowTypes/ClassType.js","../src/TypeContext.js","../src/globalContext.js","../src/index.cjs.js"],"sourcesContent":["/* @flow */\n\n/**\n * This file exports a dictionary of global primitive types that are shared by all contexts.\n * It is populated in [registerPrimitiveTypes()](./registerPrimitiveTypes.js).\n */\n\nimport type {\n  Type,\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\n/**\n * Covers our builtin types and makes room for future ones.\n */\ntype PrimitiveTypes = {\n  null: NullLiteralType;\n  empty: EmptyType;\n  number: NumberType;\n  boolean: BooleanType;\n  string: StringType;\n  symbol: SymbolType;\n  any: AnyType;\n  mixed: MixedType;\n  void: VoidType;\n  existential: ExistentialType;\n\n  [name: string]: Type<any>;\n};\n\nconst primitiveTypes: any = {};\n\n(primitiveTypes: PrimitiveTypes);\n\nexport default primitiveTypes;","/* @flow */\n\nimport {stringifyPath, resolvePath} from '../Validation';\nimport type Validation from '../Validation';\n\nexport default function makeJSONError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const errors = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : null;\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n    const field = stringifyPath(validation.path.concat(path));\n\n    const pointer = `/${path.join('/')}`;\n\n    errors.push({\n      pointer,\n      field,\n      message,\n      expected,\n      actual\n    });\n  }\n  return errors;\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\n// Tracks whether we're in validation of cyclic objects.\nconst cyclicValidation = new WeakMap();\n// Tracks whether we're toString() of cyclic objects.\nconst cyclicToString = new WeakSet();\n\nexport function inValidationCycle (type: Type<any>, input: any): boolean {\n  try {\n    const tracked = cyclicValidation.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n  catch (e) {\n    // some exotic values cannot be checked\n    return true;\n  }\n}\n\nexport function startValidationCycle (type: Type<any>, input: any) {\n  let tracked = cyclicValidation.get(type);\n  if (!tracked) {\n    tracked = new WeakSet();\n    cyclicValidation.set(type, tracked);\n  }\n  weakSetAdd(tracked, input);\n}\n\nexport function endValidationCycle (type: Type<any>, input: any) {\n  const tracked = cyclicValidation.get(type);\n  if (tracked) {\n    weakSetDelete(tracked, input);\n  }\n}\n\nexport function inToStringCycle (type: Type<any>): boolean {\n  return cyclicToString.has(type);\n}\n\nexport function startToStringCycle (type: Type<any>) {\n  cyclicToString.add(type);\n}\n\nexport function endToStringCycle (type: Type<any>) {\n  cyclicToString.delete(type);\n}\n\n\nexport function weakSetHas <V: any> (weakset: WeakSet<V>, value: V): boolean {\n  try {\n    return weakset.has(value);\n  }\n  catch (e) {\n    return true;\n  }\n}\n\n\nexport function weakSetAdd <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.add(value);\n  }\n  catch (e) {}\n}\n\n\nexport function weakSetDelete <V: any> (weakset: WeakSet<V>, value: V) {\n  try {\n    weakset.delete(value);\n  }\n  catch (e) {}\n}","/* @flow */\nimport makeJSONError from './errorReporting/makeJSONError';\n\nimport {weakSetHas, weakSetAdd, weakSetDelete} from './cyclic';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\nexport type IdentifierPath = Array<string | number>;\nexport type ErrorTuple = [IdentifierPath, string, Type<any>];\n\nexport type ValidationJSON<T> = {\n  input: T;\n  errors: Array<{\n    pointer: string;\n    message: string;\n    expected: Type<any>;\n    actual: Type<any>;\n  }>\n};\n\nconst validIdentifierOrAccessor = /^[$A-Z_][0-9A-Z_$[\\].]*$/i;\n\n\nexport default class Validation<T> {\n\n  context: TypeContext;\n\n  input: T;\n\n  path: string[] = [];\n\n  prefix: string = '';\n\n  errors: ErrorTuple[] = [];\n\n  // Tracks whether we're in validation of cyclic objects.\n  cyclic: WeakMap<Type<any>, WeakSet<any>> = new WeakMap();\n\n  constructor (context: TypeContext, input: T) {\n    this.context = context;\n    this.input = input;\n  }\n\n  inCycle (type: Type<any>, input: any): boolean {\n    const tracked = this.cyclic.get(type);\n    if (!tracked) {\n      return false;\n    }\n    else {\n      return weakSetHas(tracked, input);\n    }\n  }\n\n  startCycle (type: Type<any>, input: any) {\n    let tracked = this.cyclic.get(type);\n    if (!tracked) {\n      tracked = new WeakSet();\n      this.cyclic.set(type, tracked);\n    }\n    weakSetAdd(tracked, input);\n  }\n\n  endCycle (type: Type<any>, input: any) {\n    const tracked = this.cyclic.get(type);\n    if (tracked) {\n      weakSetDelete(tracked, input);\n    }\n  }\n\n  hasErrors (path: ? IdentifierPath): boolean {\n    if (path) {\n      for (const [candidate] of this.errors) {\n        if (matchPath(path, candidate)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    else {\n      return this.errors.length > 0;\n    }\n  }\n\n  addError (path: IdentifierPath, expectedType: Type<any>, message: string): this {\n    this.errors.push([path, message, expectedType]);\n    return this;\n  }\n\n  clearError (path: ? IdentifierPath): boolean {\n    let didClear = false;\n    if (path) {\n      const errors = [];\n      for (const error of this.errors) {\n        if (matchPath(path, error[0])) {\n          didClear = true;\n        }\n        else {\n          errors.push(error);\n        }\n      }\n      this.errors = errors;\n    }\n    else {\n      didClear = this.errors.length > 0;\n      this.errors = [];\n    }\n    return didClear;\n  }\n\n  resolvePath (path: IdentifierPath): any {\n    return resolvePath(this.input, path);\n  }\n\n  toJSON (): * {\n    return makeJSONError(this);\n  }\n\n}\n\nexport function stringifyPath (path: IdentifierPath): string {\n  if (!path.length) {\n    return 'Value';\n  }\n  const {length} = path;\n  const parts = new Array(length);\n  for (let i = 0; i < length; i++) {\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      parts[i] = 'Return Type';\n    }\n    else if (typeof part !== 'string' || !validIdentifierOrAccessor.test(part)) {\n      parts[i] = `[${String(part)}]`;\n    }\n    else if (i > 0) {\n      parts[i] = `.${String(part)}`;\n    }\n    else {\n      parts[i] = String(part);\n    }\n  }\n  return parts.join('');\n}\n\nexport function resolvePath (input: any, path: IdentifierPath): any {\n  let subject = input;\n  const {length} = path;\n  for (let i = 0; i < length; i++) {\n    if (subject == null) {\n      return undefined;\n    }\n    const part = path[i];\n    if (part === '[[Return Type]]') {\n      continue;\n    }\n    if (subject instanceof Map) {\n      subject = subject.get(part);\n    }\n    else {\n      subject = subject[part];\n    }\n  }\n  return subject;\n}\n\nexport function matchPath (path: IdentifierPath, candidate: IdentifierPath): boolean {\n  const {length} = path;\n  if (length > candidate.length) {\n    return false;\n  }\n  for (let i = 0; i < length; i++) {\n    if (candidate[i] !== path[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n","/* @flow */\n\nimport type {ErrorTuple} from '../Validation';\n\nexport default class RuntimeTypeError extends TypeError {\n  name: string = \"RuntimeTypeError\";\n  errors: ?ErrorTuple[];\n  constructor(message: string, options?: {errors?: ErrorTuple[]}) {\n    super(message);\n    Object.assign(this, options);\n  }\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nimport RuntimeTypeError from './RuntimeTypeError';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeTypeError <T> (validation: Validation<T>) {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {prefix, input, context, errors} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = resolvePath(input, path);\n    const actualType = context.typeOf(actual).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n    const actualAsString = makeString(actual);\n\n    if (typeof actualAsString === 'string') {\n      collected.push(`${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual Value: ${actualAsString}\\n\\nActual Type: ${actualType}\\n`);\n    } else {\n      collected.push(\n        `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actualType}\\n`\n      );\n    }\n  }\n  if (prefix) {\n    return new RuntimeTypeError(`${prefix.trim()} ${collected.join(delimiter)}`, {errors});\n  }\n  else {\n    return new RuntimeTypeError(collected.join(delimiter), {errors});\n  }\n}\n\nfunction makeString(value: *) {\n  if (value === null) {\n    return 'null';\n  }\n  switch (typeof value) {\n    case 'string':\n      return `\"${value}\"`;\n    // @flowIssue\n    case 'symbol':\n    case 'number':\n    case 'boolean':\n    case 'undefined':\n      return String(value);\n    case 'function':\n      return;\n    default:\n      if (Array.isArray(value) || value.constructor == null || value.constructor === Object) {\n        try {\n          return JSON.stringify(value, null, 2);\n        }\n        catch (e) {\n          return;\n        }\n      }\n      return;\n  }\n}","/* @flow */\n\nimport type {Type} from './types';\nimport makeTypeError from './errorReporting/makeTypeError';\n\nexport default function makeError (expected: Type<any>, input: any): ? TypeError {\n  const {context} = expected;\n  const validation = context.validate(expected, input);\n  return makeTypeError(validation);\n}\n","/* @flow */\n\nimport type Type from './types/Type';\n\nimport {\n  AnyType,\n  ExistentialType,\n  TypeParameter,\n  FlowIntoType,\n  MixedType,\n  TypeAlias,\n  TypeParameterApplication,\n  TypeTDZ\n} from './types';\n\n/**\n * Given two types, A and B, compare them and return either -1, 0, or 1:\n *\n *   -1 if A cannot accept type B.\n *\n *    0 if the types are effectively identical.\n *\n *    1 if A accepts every possible B.\n */\nexport default function compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n  let result;\n\n  if (a === b) {\n    return 0;\n  }\n\n  if (b instanceof TypeAlias || b instanceof TypeParameter || b instanceof TypeParameterApplication || b instanceof TypeTDZ) {\n    b = b.unwrap();\n  }\n\n  if (a instanceof TypeAlias) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof FlowIntoType || a instanceof TypeParameter || b instanceof FlowIntoType) {\n    result = a.compareWith(b);\n  }\n  else if (a instanceof AnyType || a instanceof ExistentialType || a instanceof MixedType) {\n    return 1;\n  }\n  else {\n    result = a.compareWith(b);\n  }\n\n  if (b instanceof AnyType) {\n    // Note: This check cannot be moved higher in the scope,\n    // as this would prevent types from being propagated upwards.\n    return 1;\n  }\n  else {\n    return result;\n  }\n}\n","/* @flow */\n\nimport makeError from '../makeError';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport Validation from '../Validation';\nimport type {ErrorTuple, IdentifierPath} from '../Validation';\n\n/**\n * # Type\n *\n * This is the base class for all types.\n */\nexport default class Type <T> {\n  typeName: string = 'Type';\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    const validation = new Validation(this.context, input);\n    for (const error of this.errors(validation, [], input)) { // eslint-disable-line no-unused-vars\n      return false;\n    }\n    return true;\n  }\n\n  acceptsType (input: Type<any>): boolean {\n    if (compareTypes(this, input) === -1) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return -1;\n  }\n\n  assert <V: T> (input: V): V {\n    const error = makeError(this, input);\n    if (error) {\n      if (typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(error, this.assert);\n      }\n      throw error;\n    }\n    return input;\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString () {\n    return '$Type';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class AnyType extends Type<any> {\n  typeName: string = 'AnyType';\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return 'any';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nconst errorMessages = {\n  ERR_CONSTRAINT_VIOLATION: 'violated a constraint',\n  ERR_EXPECT_ARRAY: 'must be an Array',\n  ERR_EXPECT_TRUE: 'must be true',\n  ERR_EXPECT_FALSE: 'must be false',\n  ERR_EXPECT_BOOLEAN: 'must be true or false',\n  ERR_EXPECT_EMPTY: 'must be empty',\n  ERR_EXPECT_EXACT_VALUE: 'must be exactly $0',\n  ERR_EXPECT_CALLABLE: 'must be callable',\n  ERR_EXPECT_CLASS: 'must be a Class of $0',\n  ERR_EXPECT_FUNCTION: 'must be a function',\n  ERR_EXPECT_GENERATOR: 'must be a generator function',\n  ERR_EXPECT_ITERABLE: 'must be iterable',\n  ERR_EXPECT_ARGUMENT: 'argument \"$0\" must be: $1',\n  ERR_EXPECT_RETURN: 'expected return type of: $0',\n  ERR_EXPECT_N_ARGUMENTS: 'requires $0 argument(s)',\n  ERR_EXPECT_INSTANCEOF: 'must be an instance of $0',\n  ERR_EXPECT_KEY_TYPE: 'keys must be: $0',\n  ERR_EXPECT_NULL: 'must be null',\n  ERR_EXPECT_NUMBER: 'must be a number',\n  ERR_EXPECT_OBJECT: 'must be an object',\n  ERR_EXPECT_PROMISE: 'must be a promise of $0',\n  ERR_EXPECT_STRING: 'must be a string',\n  ERR_EXPECT_SYMBOL: 'must be a symbol',\n  ERR_EXPECT_THIS: 'must be exactly this',\n  ERR_EXPECT_VOID: 'must be undefined',\n  ERR_INVALID_DATE: 'must be a valid date',\n  ERR_MISSING_PROPERTY: 'does not exist on object',\n  ERR_NO_INDEXER: 'is not one of the permitted indexer types',\n  ERR_NO_UNION: 'must be one of: $0',\n  ERR_UNKNOWN_KEY: 'should not contain the key: \"$0\"'\n};\n\nexport type ErrorKey = $Keys<typeof errorMessages>;\n\nexport default errorMessages;\n","/* @flow */\n\nimport errorMessages from './errorMessages';\nimport type {ErrorKey} from './errorMessages';\n\n\nexport default function getErrorMessage (key: ErrorKey, ...params: any[]): string {\n  const message = errorMessages[key];\n  if (params.length > 0) {\n    return message.replace(/\\$(\\d+)/g, (m, i) => String(params[i]));\n  }\n  else {\n    return message;\n  }\n}\n\n\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TupleType<T> extends Type {\n  typeName: string = 'TupleType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path.concat(i), input[i]);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    const {context} = this;\n\n    if (!context.checkPredicate('Array', input) || input.length < length) {\n      return false;\n    }\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof TupleType)) {\n      return -1;\n    }\n    const types = this.types;\n    const inputTypes = input.types;\n    if (inputTypes.length < types.length) {\n      return -1;\n    }\n    let isGreater = false;\n    for (let i = 0; i < types.length; i++) {\n      const result = compareTypes(types[i], inputTypes[i]);\n      if (result === 1) {\n        isGreater = true;\n      }\n      else if (result === -1) {\n        return -1;\n      }\n    }\n    if (types.length < inputTypes.length) {\n      return 0;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return 0;\n    }\n  }\n\n  toString (): string {\n    return `[${this.types.join(', ')}]`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport TupleType from './TupleType';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\nexport default class ArrayType <T> extends Type {\n  typeName: string = 'ArrayType';\n  elementType: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n\n    for (let i = 0; i < length; i++) {\n      yield* elementType.errors(validation, path.concat(i), input[i]);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    const {context} = this;\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n    const {elementType} = this;\n    const {length} = input;\n    for (let i = 0; i < length; i++) {\n      if (!elementType.accepts(input[i])) {\n        endValidationCycle(this, input);\n        return false;\n      }\n    }\n    endValidationCycle(this, input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {elementType} = this;\n    if (input instanceof TupleType) {\n      const {types} = input;\n      for (let i = 0; i < types.length; i++) {\n        const result = compareTypes(elementType, types[i]);\n        if (result === -1) {\n          return -1;\n        }\n      }\n      return 1;\n    }\n    else if (input instanceof ArrayType) {\n      return compareTypes(elementType, input.elementType);\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {elementType} = this;\n    if (inToStringCycle(this)) {\n      if (typeof elementType.name === 'string') {\n        return `Array<$Cycle<${elementType.name}>>`;\n      }\n      else {\n        return `Array<$Cycle<Object>>`;\n      }\n    }\n    startToStringCycle(this);\n    const output = `Array<${elementType.toString()}>`;\n    endToStringCycle(this);\n    return output;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      elementType: this.elementType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanLiteralType <T: boolean> extends Type {\n  typeName: string = 'BooleanLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== this.value) {\n      yield [path, getErrorMessage(this.value ? 'ERR_EXPECT_TRUE' : 'ERR_EXPECT_FALSE'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return this.value ? 'true' : 'false';\n  }\n\n  toJSON () {\n    return {\n      type: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport BooleanLiteralType from './BooleanLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class BooleanType extends Type {\n  typeName: string = 'BooleanType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'boolean') {\n      yield [path, getErrorMessage('ERR_EXPECT_BOOLEAN'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'boolean';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof BooleanLiteralType) {\n      return 1;\n    }\n    else if (input instanceof BooleanType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'boolean';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class EmptyType extends Type {\n  typeName: string = 'EmptyType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield [path, getErrorMessage('ERR_EXPECT_EMPTY'), this];\n  }\n\n  accepts (input: any): boolean {\n    return false; // empty types accepts nothing.\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof EmptyType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'empty';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ExistentialType extends Type {\n  typeName: string = 'ExistentialType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  toString (): string {\n    return '*';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ApplicableType} from './';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\n/**\n * # TypeParameterApplication\n *\n */\nexport default class TypeParameterApplication<X, T> extends Type {\n  typeName: string = 'TypeParameterApplication';\n  parent: ApplicableType<T>;\n  typeInstances: Type<X>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {parent, typeInstances} = this;\n    yield* parent.errors(validation, path, input, ...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    const {parent, typeInstances} = this;\n    return parent.accepts(input, ...typeInstances);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return this.parent.compareWith(input, ...this.typeInstances);\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).hasProperty === 'function') {\n      return (inner: $FlowIgnore).hasProperty(name, ...this.typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.parent;\n    if (inner && typeof (inner: $FlowIgnore).getProperty === 'function') {\n      return (inner: $FlowIgnore).getProperty(name, ...this.typeInstances);\n    }\n  }\n\n  unwrap () {\n    return this.parent.unwrap(...this.typeInstances);\n  }\n\n  toString (): string {\n    const {parent, typeInstances} = this;\n    const {name} = parent;\n    if (typeInstances.length) {\n      const items = [];\n      for (let i = 0; i < typeInstances.length; i++) {\n        const typeInstance = typeInstances[i];\n        items.push(typeInstance.toString());\n      }\n      return `${name}<${items.join(', ')}>`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeInstances: this.typeInstances\n    };\n  }\n}\n","/* @flow */\n\nimport type {\n  Type,\n  TypeConstraint\n} from './types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport type ConstrainableType<T> = Type<T> & {constraints: TypeConstraint[]};\n\n/**\n * Add constraints to the given subject type.\n */\nexport function addConstraints (subject: ConstrainableType<any>, ...constraints: TypeConstraint[]) {\n  subject.constraints.push(...constraints);\n}\n\n/**\n * Collect any errors from constraints on the given subject type.\n */\nexport function *collectConstraintErrors (subject: ConstrainableType<any>, validation: Validation<any>, path: IdentifierPath, ...input: any[]): Generator<ErrorTuple, void, void> {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    const violation = constraint(...input);\n    if (typeof violation === 'string') {\n      yield [path, violation, this];\n    }\n  }\n}\n\n/**\n * Determine whether the input passes the constraints on the subject type.\n */\nexport function constraintsAccept (subject: ConstrainableType<any>, ...input: any[]): boolean {\n  const {constraints} = subject;\n  const {length} = constraints;\n  for (let i = 0; i < length; i++) {\n    const constraint = constraints[i];\n    if (typeof constraint(...input) === 'string') {\n      return false;\n    }\n  }\n  return true;\n}","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class TypeAlias<T> extends Type {\n  typeName: string = 'TypeAlias';\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): TypeAlias<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  get properties () {\n    return this.type.properties;\n  }\n\n  get hasConstraints (): boolean {\n    return this.constraints.length > 0;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const {name, type} = this;\n    if (withDeclaration) {\n      return `type ${name} = ${type.toString()};`;\n    }\n    else {\n      return name;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport FlowIntoType from \"./FlowIntoType\";\nimport TypeAlias from './TypeAlias';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nconst FlowIntoSymbol = Symbol('FlowInto');\n\n/**\n * # TypeParameter\n *\n * Type parameters allow polymorphic type safety.\n * The first time a type parameter is checked, it records the shape of its input,\n * this recorded shape is used to check all future inputs for this particular instance.\n */\nexport default class TypeParameter<T> extends Type {\n  typeName: string = 'TypeParameter';\n  id: string;\n  bound: ? Type<T>;\n  default: ? Type<T>;\n\n  recorded: ? Type<T>;\n\n  // @flowIssue 252\n  [FlowIntoSymbol]: ? FlowIntoType = null;\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      yield* boundOrDefault.errors(validation, path, input);\n      return;\n    }\n    else if (recorded) {\n      // we've already recorded a value for this type parameter\n      yield* recorded.errors(validation, path, input);\n      return;\n    }\n    else if (boundOrDefault) {\n      if (boundOrDefault.typeName === 'AnyType' || boundOrDefault.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasErrors = false;\n        for (const error of boundOrDefault.errors(validation, path, input)) {\n          hasErrors = true;\n          yield error;\n        }\n        if (hasErrors) {\n          return;\n        }\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded, context} = this;\n    if (boundOrDefault instanceof FlowIntoType || boundOrDefault instanceof TypeAlias) {\n      // We defer to the other type parameter so that values from this\n      // one can flow \"upwards\".\n      return boundOrDefault.accepts(input);\n    } else if (recorded) {\n      return recorded.accepts(input);\n    } else if (boundOrDefault) {\n      if (boundOrDefault.typeName === \"AnyType\" || boundOrDefault.typeName === \"ExistentialType\") {\n        return true;\n      } else if (!boundOrDefault.accepts(input)) {\n        return false;\n      }\n    }\n\n    this.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (input instanceof TypeParameter) {\n      // We don't need to check for `recorded` or `bound` fields\n      // because the input has already been unwrapped, so\n      // if we got a type parameter it must be totally generic and\n      // we treat it like Any.\n      return 1;\n    }\n    else if (recorded) {\n      return compareTypes(recorded, input);\n    }\n    else if (boundOrDefault) {\n      return compareTypes(boundOrDefault, input);\n    }\n    else {\n      // A generic type parameter accepts any input.\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    const boundOrDefault = this.bound || this.default;\n    const {recorded} = this;\n    if (recorded) {\n      return recorded.unwrap();\n    }\n    else if (boundOrDefault) {\n      return boundOrDefault.unwrap();\n    }\n    else {\n      return this;\n    }\n  }\n\n  toString (withBinding?: boolean): string {\n    const {id, bound, default: defaultType} = this;\n    if (withBinding) {\n      if (defaultType) {\n        return `${id} = ${defaultType.toString()}`;\n      }\n      else if (bound) {\n        return `${id}: ${bound.toString()}`;\n      }\n    }\n    return id;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      bound: this.bound,\n      recorded: this.recorded\n    };\n  }\n}\n\nexport function flowIntoTypeParameter <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n  const existing: ? FlowIntoType<T> = (typeParameter: $FlowIssue<252>)[FlowIntoSymbol];\n  if (existing) {\n    return existing;\n  }\n\n  const target = new FlowIntoType(typeParameter.context);\n  target.typeParameter = typeParameter;\n  (typeParameter: $FlowIssue<252>)[FlowIntoSymbol] = target;\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\n\n/**\n * # FlowIntoType\n *\n * A virtual type which allows types it receives to \"flow\" upwards into a type parameter.\n * The type parameter will become of a union of any types seen by this instance.\n */\nexport default class FlowIntoType<T: any> extends Type {\n  typeName: string = 'FlowIntoType';\n\n  typeParameter: TypeParameter<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      yield* bound.errors(validation, path, input);\n      return;\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound) {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return;\n      }\n      else {\n        let hasError = false;\n        for (const error of bound.errors(validation, path, input)) {\n          yield error;\n          hasError = true;\n        }\n        if (hasError) {\n          return;\n        }\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n  }\n\n  accepts (input: any): boolean {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.accepts(input);\n    }\n    if (recorded) {\n      // we've already recorded a value for this type parameter\n      if (bound && !bound.accepts(input)) {\n        return false;\n      }\n      else if (recorded.accepts(input)) {\n        // our existing type already permits this value, there's nothing to do.\n        return true;\n      }\n      else {\n        // we need to make a union\n        typeParameter.recorded = context.union(recorded, context.typeOf(input));\n        return true;\n      }\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return true;\n      }\n      else if (!bound.accepts(input)) {\n        return false;\n      }\n    }\n\n    typeParameter.recorded = context.typeOf(input);\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {typeParameter, context} = this;\n\n    const {recorded, bound} = typeParameter;\n    if (bound instanceof FlowIntoType) {\n      // We defer to the other type so that values from this\n      // one can flow \"upwards\".\n      return bound.compareWith(input);\n    }\n    if (recorded) {\n      if (bound && compareTypes(bound, input) === -1) {\n        return -1;\n      }\n      const result = compareTypes(recorded, input);\n      if (result === 0) {\n        // our existing type already permits this value, there's nothing to do.\n        return 0;\n      }\n      // we need to make a union\n      typeParameter.recorded = context.union(recorded, input);\n      return 1;\n    }\n    else if (bound) {\n      if (bound.typeName === 'AnyType' || bound.typeName === 'ExistentialType') {\n        return 1;\n      }\n      const result = compareTypes(bound, input);\n      if (result === -1) {\n        return -1;\n      }\n    }\n\n    typeParameter.recorded = input;\n    return 0;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.typeParameter.unwrap();\n  }\n\n  toString (withBinding?: boolean): string {\n    return this.typeParameter.toString(withBinding);\n  }\n\n  toJSON () {\n    return this.typeParameter.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class FunctionTypeRestParam<T> extends Type {\n  typeName: string = 'FunctionTypeRestParam';\n  name: string;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `...${this.name}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\n\nexport default class FunctionTypeParam<T> extends Type {\n  typeName: string = 'FunctionTypeParam';\n  name: string;\n  optional: boolean;\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return;\n    }\n    else {\n      yield* type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {optional, type} = this;\n    if (optional && input === undefined) {\n      return true;\n    }\n    else {\n      return type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeParam || input instanceof FunctionTypeRestParam) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (): string {\n    const {optional, type} = this;\n    return `${this.name}${optional ? '?' : ''}: ${type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name,\n      optional: this.optional,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class FunctionTypeReturn<T> extends Type {\n  typeName: string = 'FunctionTypeReturn';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    yield* type.errors(validation, path.concat('[[Return Type]]'), input);\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    return type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof FunctionTypeReturn) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  unwrap (): Type<T> {\n    return this.type;\n  }\n\n  toString (): string {\n    const {type} = this;\n    return type.toString();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nexport const ParentSymbol = Symbol('Parent');\nexport const NameRegistrySymbol = Symbol('NameRegistry');\nexport const ModuleRegistrySymbol = Symbol('ModuleRegistry');\nexport const CurrentModuleSymbol = Symbol('CurrentModule');\nexport const TypeConstructorRegistrySymbol = Symbol('TypeConstructorRegistry');\nexport const InferrerSymbol = Symbol('Inferrer');\nexport const TraverseValueSymbol = Symbol('TraverseValue');\nexport const TraverseTypeSymbol = Symbol('TraverseType');\nexport const TypeSymbol = Symbol('Type');\nexport const TypeParametersSymbol = Symbol('TypeParameters');\nexport const TypePredicateRegistrySymbol = Symbol('TypePredicateRegistry');\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport FunctionTypeParam from './FunctionTypeParam';\nimport FunctionTypeRestParam from './FunctionTypeRestParam';\nimport FunctionTypeReturn from './FunctionTypeReturn';\nimport EmptyType from './EmptyType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {TypeSymbol} from '../symbols';\n\nexport default class FunctionType<P, R> extends Type {\n  typeName: string = 'FunctionType';\n  params: FunctionTypeParam<P>[] = [];\n  rest: ? FunctionTypeRestParam<P>;\n  returnType: FunctionTypeReturn<R>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n      return;\n    }\n    const annotation = input[TypeSymbol];\n    const {returnType, params} = this;\n    if (annotation) {\n      if (!annotation.params) {\n        return;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          yield [\n            path,\n            getErrorMessage('ERR_EXPECT_ARGUMENT', param.name, param.type.toString()),\n            this\n          ];\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        yield [\n          path,\n          getErrorMessage('ERR_EXPECT_RETURN', returnType.toString()),\n          this\n        ];\n      }\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const {returnType, params} = this;\n    const annotation = input[TypeSymbol];\n    if (annotation) {\n      if (!annotation.params) {\n        return true;\n      }\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const annotationParam = annotation.params[i];\n        if (!annotationParam && !param.optional) {\n          return false;\n        }\n        else if (!param.acceptsType(annotationParam)) {\n          return false;\n        }\n      }\n      if (!returnType.acceptsType(annotation.returnType)) {\n        return false;\n      }\n      return true;\n    }\n    else {\n      const {context} = this;\n      // We cannot safely check an unannotated function.\n      // But we need to propagate `any` type feedback upwards.\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        param.acceptsType(context.any());\n      }\n      returnType.acceptsType(context.any());\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof FunctionType)) {\n      return -1;\n    }\n    const returnType = this.returnType;\n    const inputReturnType = input.returnType;\n    let isGreater = false;\n    const returnTypeResult = compareTypes(returnType, inputReturnType);\n    if (returnTypeResult === -1) {\n      return -1;\n    }\n    else if (returnTypeResult === 1) {\n      isGreater = true;\n    }\n\n    const params = this.params;\n    const inputParams = input.params;\n    for (let i = 0; i < params.length; i++) {\n      const param = params[i];\n      const inputParam = i >= inputParams.length ? input.rest : inputParams[i];\n      if (inputParam == null) {\n        return -1;\n      }\n      const result = compareTypes(param, inputParam);\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.accepts(args[i])) {\n          return false;\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return false;\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.accepts(args[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  assertParams (...args: any[]): P[] {\n    const {params, rest} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        param.assert(args[i]);\n      }\n      else {\n        param.assert(undefined);\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        rest.assert(args[i]);\n      }\n    }\n\n    return args;\n  }\n\n  assertReturn <T> (input: any): T {\n    this.returnType.assert(input);\n    return input;\n  }\n\n  invoke (...args: Type<P>[]): Type<R> | EmptyType {\n    const {params, rest, context} = this;\n    const paramsLength = params.length;\n    const argsLength = args.length;\n    for (let i = 0; i < paramsLength; i++) {\n      const param = params[i];\n      if (i < argsLength) {\n        if (!param.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n      else if (!param.accepts(undefined)) {\n        return context.empty();\n      }\n    }\n\n    if (argsLength > paramsLength && rest) {\n      for (let i = paramsLength; i < argsLength; i++) {\n        if (!rest.acceptsType(args[i])) {\n          return context.empty();\n        }\n      }\n    }\n\n    return this.returnType.type;\n  }\n\n  toString (): string {\n    const {params, rest, returnType} = this;\n    const args = [];\n    for (let i = 0; i < params.length; i++) {\n      args.push(params[i].toString());\n    }\n    if (rest) {\n      args.push(rest.toString());\n    }\n    return `(${args.join(', ')}) => ${returnType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      params: this.params,\n      rest: this.rest,\n      returnType: this.returnType\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class GeneratorType<Y, R, N> extends Type {\n  typeName: string = 'GeneratorType';\n  yieldType: Type<Y>;\n  returnType: Type<R>;\n  nextType: Type<N>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const isValid = input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_GENERATOR'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input\n      && typeof input.next === 'function'\n      && typeof input.return === 'function'\n      && typeof input.throw === 'function'\n      ;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof GeneratorType)) {\n      const result = compareTypes(this.yieldType, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n    let isGreater = false;\n    let result = compareTypes(this.yieldType, input.yieldType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.returnType, input.returnType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    result = compareTypes(this.nextType, input.nextType);\n    if (result === -1) {\n      return -1;\n    }\n    else if (result === 1) {\n      isGreater = true;\n    }\n\n    return isGreater ? 1 : 0;\n  }\n\n  acceptsYield (input: any): boolean {\n    return this.yieldType.accepts(input);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return this.returnType.accepts(input);\n  }\n\n  acceptsNext (input: any): boolean {\n    return this.nextType.accepts(input);\n  }\n\n  assertYield (input: Y): Y {\n    return this.yieldType.assert(input);\n  }\n\n  assertReturn (input: R): R {\n    return this.returnType.assert(input);\n  }\n\n  assertNext (input: N): N {\n    return this.nextType.assert(input);\n  }\n\n  toString (): string {\n    const {yieldType, returnType, nextType} = this;\n    return `Generator<${yieldType.toString()}, ${returnType.toString()}, ${nextType.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      yieldType: this.yieldType,\n      returnType: this.returnType,\n      nextType: this.nextType\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type {Constructor} from './';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeConstructor<T> extends Type {\n  typeName: string = 'TypeConstructor';\n  name: string;\n  impl: ? Constructor<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts <P> (input: any, ...typeInstances: Type<P>[]): boolean {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement accepts().`);\n      warnedInstances.add(this);\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {context, name} = this;\n    if (!warnedInstances.has(this)) {\n      context.emitWarningMessage(`TypeConstructor ${name} does not implement compareWith().`);\n      warnedInstances.add(this);\n    }\n    return -1;\n  }\n\n  inferTypeParameters <P> (input: any): Type<P>[] {\n    return [];\n  }\n\n  apply <P> (...typeInstances: Type<P>[]): TypeParameterApplication<P, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): TypeConstructor<T> {\n    return this;\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n\n}\n","/* @flow */\n\nimport TypeConstructor from \"./TypeConstructor\";\n\nimport type Type from \"./Type\";\nimport compareTypes from \"../compareTypes\";\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, { ErrorTuple, IdentifierPath } from \"../Validation\";\n\nexport default class GenericType extends TypeConstructor {\n  typeName: string = \"GenericType\";\n\n  *errors(\n    validation: Validation<any>,\n    path: IdentifierPath,\n    input: any\n  ): Generator<ErrorTuple, void, void> {\n    const { name, impl } = this;\n    if (!(input instanceof impl)) {\n      yield [path, getErrorMessage(\"ERR_EXPECT_INSTANCEOF\", name), this];\n    }\n  }\n\n  accepts<P>(input: any, ...typeInstances: Type<P>[]): boolean {\n    const { impl } = this;\n    return input instanceof impl;\n  }\n\n  compareWith<P>(input: Type<any>, ...typeInstances: Type<P>[]): -1 | 0 | 1 {\n    const { context, impl } = this;\n    const annotation = context.getAnnotation(impl);\n    if (annotation) {\n      const expected = annotation.unwrap(...typeInstances);\n      return compareTypes(input, expected);\n    } else if (\n      input instanceof GenericType &&\n      (input.impl === impl || (impl && impl.isPrototypeOf(input.impl)))\n    ) {\n      return 0;\n    } else {\n      return -1;\n    }\n  }\n\n  unwrap<P>(...typeInstances: Type<P>[]) {\n    const { context, impl } = this;\n    if (typeof impl !== \"function\") {\n      return this;\n    }\n    const annotation = context.getAnnotation(impl);\n    if (annotation != null) {\n      return (annotation.unwrap(...typeInstances): any);\n    } else {\n      return this;\n    }\n  }\n\n  inferTypeParameters<P>(input: any): Type<P>[] {\n    return [];\n  }\n}\n","/* @flow */\n\nexport default function invariant (input: any, message: string): void {\n  if (!input) {\n    const error = new Error(message);\n    error.name = 'InvariantViolation';\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(error, invariant);\n    }\n    throw error;\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullLiteralType extends Type {\n  typeName: string = 'NullLiteralType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== null) {\n      yield [path, getErrorMessage('ERR_EXPECT_NULL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === null;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'null';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class VoidType extends Type {\n  typeName: string = 'VoidType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input !== undefined) {\n      yield [path, getErrorMessage('ERR_EXPECT_VOID'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === undefined;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof VoidType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'void';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport NullLiteralType from './NullLiteralType';\nimport VoidType from './VoidType';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NullableType<T> extends Type<T> {\n  typeName: string = 'NullableType';\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input != null) {\n      yield* this.type.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    if (input == null) {\n      return true;\n    }\n    else {\n      return this.type.accepts(input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NullLiteralType || input instanceof VoidType) {\n      return 1;\n    }\n    else if (input instanceof NullableType) {\n      return compareTypes(this.type, input.type);\n    }\n    else {\n      const result = compareTypes(this.type, input);\n      if (result === -1) {\n        return -1;\n      }\n      else {\n        return 1;\n      }\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (): string {\n    return `? ${this.type.toString()}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport NullableType from './NullableType';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n\nexport default class ObjectTypeProperty<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeProperty';\n  key: K;\n  value: Type<V>;\n  optional: boolean;\n  // @flowIgnore\n  'static': boolean = false;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): ObjectTypeProperty<K, V> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n  \n  /**\n   * Determine whether the property is nullable.\n   */\n  isNullable(): boolean {\n    return this.value instanceof NullableType;\n  }\n  \n  /**\n   * Determine whether the property exists on the given input or its prototype chain.\n   */\n  existsOn(input: Object): boolean {\n    // @flowIgnore\n    const {key, static: isStatic} = this;\n    return key in (isStatic ? input.constructor : input) === true;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        if (!optional) {\n          yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        }\n        return;\n      }\n      targetPath.push(key);\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n      targetPath = path.concat(key);\n    }\n    if (optional && target === undefined) {\n      return;\n    }\n    if (this.isNullable() && !this.existsOn(input)) {\n      yield [targetPath, getErrorMessage('ERR_MISSING_PROPERTY'), this];\n      return;\n    }\n    let hasErrors = false;\n    for (const error of value.errors(validation, targetPath, target)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, targetPath, target);\n    }\n  }\n\n  accepts (input: Object): boolean {\n    // @flowIgnore\n    const {optional, key, value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return optional ? true : false;\n      }\n      target = input.constructor[key];\n    }\n    else {\n      target = input[key];\n    }\n    \n    if (optional && target === undefined) {\n      return true;\n    }\n    \n    if (this.isNullable() && !this.existsOn(input)) {\n      return false;\n    }\n    \n    if (!value.accepts(target)) {\n      return false;\n    }\n    else {\n      return constraintsAccept(this, target);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeProperty)) {\n      return -1;\n    }\n    else if (input.key !== this.key) {\n      return -1;\n    }\n    else {\n      return compareTypes(this.value, input.value);\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    let key = this.key;\n    // @flowIssue 252\n    if (typeof key === 'symbol') {\n      key = `[${key.toString()}]`;\n    }\n    if (this.static) {\n      return `static ${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n    else {\n      return `${key}${this.optional ? '?' : ''}: ${this.value.toString()};`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      key: this.key,\n      value: this.value,\n      optional: this.optional\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport ObjectTypeProperty from './ObjectTypeProperty';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeIndexer<K: string | number, V> extends Type {\n  typeName: string = 'ObjectTypeIndexer';\n  id: string;\n  key: Type<K>;\n  value: Type<V>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, key: any, value: any): Generator<ErrorTuple, void, void> {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n\n    yield* this.key.errors(validation, path.concat('[[Key]]'), key);\n    yield* this.value.errors(validation, path.concat(key), value);\n  }\n\n  accepts (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  acceptsKey (key: any): boolean {\n    // special case number types\n    if (this.key.typeName === 'NumberType' || this.key.typeName === 'NumericLiteralType') {\n      key = +key;\n    }\n    return this.key.accepts(key);\n  }\n\n  acceptsValue (value: any): boolean {\n    return this.value.accepts(value);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ObjectTypeProperty) {\n      if (!this.key.accepts(input.key)) {\n        return -1;\n      }\n      else {\n        return compareTypes(this.value, input.value);\n      }\n    }\n    else if (!(input instanceof ObjectTypeIndexer)) {\n      return -1;\n    }\n\n    const keyResult = compareTypes(this.key, input.key);\n    if (keyResult === -1) {\n      return -1;\n    }\n    const valueResult = compareTypes(this.value, input.value);\n    if (valueResult === -1) {\n      return -1;\n    }\n\n    if (keyResult === 0 && valueResult === 0) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  unwrap (): Type<V> {\n    return this.value.unwrap();\n  }\n\n  toString (): string {\n    return `[${this.id}: ${this.key.toString()}]: ${this.value.toString()};`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      id: this.id,\n      key: this.key,\n      value: this.value\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport getErrorMessage from \"../getErrorMessage\";\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ObjectTypeCallProperty<T: Function> extends Type {\n  typeName: string = 'ObjectTypeCallProperty';\n  value: Type<T>;\n  // @flowIgnore\n  'static': boolean = false;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n\n    let target;\n    let targetPath;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      targetPath = path.concat('constructor');\n      if (typeof input.constructor !== 'function') {\n        yield [targetPath, getErrorMessage('ERR_EXPECT_FUNCTION'), this];\n        return;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n      targetPath = path;\n    }\n    yield* value.errors(validation, targetPath, target);\n  }\n\n  accepts (input: any): boolean {\n    // @flowIgnore\n    const {value, static: isStatic} = this;\n    let target;\n    if (isStatic) {\n      if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n        return false;\n      }\n      if (typeof input.constructor !== 'function') {\n        return false;\n      }\n      target = input.constructor;\n    }\n    else {\n      target = input;\n    }\n    return value.accepts(target);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectTypeCallProperty)) {\n      return -1;\n    }\n    return compareTypes(this.value, input.value);\n  }\n\n  unwrap (): Type<T> {\n    return this.value.unwrap();\n  }\n\n\n  toString (): string {\n    if (this.static) {\n      return `static ${this.value.toString()};`;\n    }\n    else {\n      return this.value.toString();\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nexport default class Declaration extends Type {\n  name: string;\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {Type, TypeConstraint} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class VarDeclaration<T> extends Declaration {\n  typeName: string = 'VarDeclaration';\n\n  name: string;\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): VarDeclaration<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare var ${this.name}: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport compareTypes from '../compareTypes';\n\nimport type {\n  Type,\n  TypeAlias,\n  ParameterizedTypeAlias,\n  TypeConstraint,\n  TypeParameterApplication,\n  ObjectTypeProperty\n} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class TypeDeclaration<T> extends Declaration {\n  typeName: string = 'TypeDeclaration';\n\n  get type (): Type<T> {\n    return this.typeAlias.type;\n  }\n\n  typeAlias: TypeAlias<T> | ParameterizedTypeAlias<T>;\n\n  addConstraint (...constraints: TypeConstraint[]): TypeDeclaration<T> {\n    this.typeAlias.addConstraint(...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.typeAlias.errors(validation, path, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    return this.typeAlias.apply(...typeInstances);\n  }\n\n  accepts (input: any): boolean {\n    return this.typeAlias.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.typeAlias, input);\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    return this.typeAlias.hasProperty(name, ...typeInstances);\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    return this.typeAlias.getProperty(name, ...typeInstances);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return this.typeAlias.unwrap(...typeInstances);\n  }\n\n  toString (): string {\n    return `declare ${this.typeAlias.toString(true)};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\nimport type ModuleExportsDeclaration from './ModuleExportsDeclaration';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type DeclarationDict = {\n  [name: string]: Type<any>;\n};\n\nexport type ModuleDeclarationDict = {\n  [name: string]: ModuleDeclaration;\n};\n\nimport {NameRegistrySymbol, ModuleRegistrySymbol} from '../symbols';\n\nexport default class ModuleDeclaration extends Declaration {\n  typeName: string = 'ModuleDeclaration';\n\n\n  name: string;\n  innerContext: TypeContext;\n  moduleExports: ? ModuleExportsDeclaration<any>;\n\n  get moduleType (): 'commonjs' | 'es6' {\n    if (this.moduleExports) {\n      return 'commonjs';\n    }\n    else {\n      return 'es6';\n    }\n  }\n\n  get isCommonJS (): boolean {\n    return this.moduleExports ? true : false;\n  }\n\n  get isES6 (): boolean {\n    return this.moduleExports ? false : true;\n  }\n\n  get declarations (): DeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[NameRegistrySymbol];\n  }\n\n  get modules (): ModuleDeclarationDict {\n    const {innerContext} = this;\n    return (innerContext: $FlowIssue<252>)[ModuleRegistrySymbol];\n  }\n\n  get (name: string): ? Type<any> {\n    const {moduleExports} = this;\n    if (moduleExports) {\n      const exporting = moduleExports.unwrap();\n      if (typeof exporting.getProperty === 'function') {\n        const prop = exporting.getProperty(name);\n        if (prop) {\n          return prop.unwrap();\n        }\n      }\n    }\n    else {\n      const declaration = this.declarations[name];\n      if (declaration) {\n        return declaration.unwrap();\n      }\n    }\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // Can't validate a module directly.\n    // @todo should this throw?\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    if (/^\\.\\//.test(moduleName)) {\n      moduleName = `${this.name}${moduleName.slice(1)}`;\n    }\n    return this.innerContext.import(moduleName);\n  }\n\n  toString (): string {\n\n    const {name, declarations, modules, moduleExports} = this;\n    const body = [];\n    for (const name in declarations) { // eslint-disable-line guard-for-in\n      const declaration = declarations[name];\n      body.push(declaration.toString(true));\n    }\n    if (modules) {\n      for (const name in modules) { // eslint-disable-line guard-for-in\n        const module = modules[name];\n        body.push(module.toString());\n      }\n    }\n    if (moduleExports) {\n      body.push(moduleExports.toString());\n    }\n    return `declare module \"${name}\" {\\n${indent(body.join('\\n\\n'))}}`;\n  }\n}\n\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class ModuleExports<T> extends Declaration {\n  typeName: string = 'ModuleExports';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return `declare module.exports: ${this.type.toString()};`;\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport getErrorMessage from \"../getErrorMessage\";\nimport compareTypes from '../compareTypes';\n\nimport type ParameterizedClassDeclaration from './ParameterizedClassDeclaration';\n\nimport type {Type, ObjectType} from '../types';\n\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ClassDeclaration<O: {}> extends Declaration {\n  typeName: string = 'ClassDeclaration';\n\n  name: string;\n  superClass: ? Type<any>;\n  body: ObjectType<O>;\n\n  shapeID: Symbol = Symbol();\n\n  get properties (): Array<*> {\n    const {body, superClass} = this;\n    if (superClass == null) {\n      return body.properties;\n    }\n    const bodyProps = body.properties;\n    const superProps = (superClass.unwrap(): $FlowFixme).properties;\n    if (superProps == null) {\n      return bodyProps;\n    }\n    const seen = {};\n    const seenStatic = {};\n    const props = [];\n    for (let i = 0; i < superProps.length; i++) {\n      const prop = superProps[i];\n      props.push(prop);\n      if (prop.static) {\n        seenStatic[prop.key] = i;\n      }\n      else {\n        seen[prop.key] = i;\n      }\n    }\n    for (let i = 0; i < bodyProps.length; i++) {\n      const prop = bodyProps[i];\n      if (seen[prop.key]) {\n        props[i] = prop;\n      }\n      else {\n        props.push(prop);\n      }\n    }\n    return props;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', this.name), this];\n      return;\n    }\n    if (superClass) {\n      for (const [errorPath, errorMessage, expectedType] of superClass.errors(validation, path, input)) {\n        const propertyName = errorPath[path.length];\n        if (body.getProperty(propertyName)) {\n          continue;\n        }\n        else {\n          yield [errorPath, errorMessage, expectedType];\n        }\n      }\n    }\n    yield* body.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    const {body} = this;\n    const superClass = this.superClass && this.superClass.unwrap();\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    else if (superClass && !superClass.accepts(input)) {\n      return false;\n    }\n    else if (!body.accepts(input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof ClassDeclaration) {\n      if (input === this) {\n        return 0;\n      }\n      else if (this.isSuperClassOf(input)) {\n        return 1;\n      }\n      else {\n        return -1;\n      }\n    }\n    return compareTypes(this.body, input);\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<O>, any> {\n    const {body, superClass} = this;\n    const prop = body.getProperty(key);\n    if (prop) {\n      return prop;\n    }\n    else if (superClass && typeof superClass.getProperty === 'function') {\n      return superClass.getProperty(key);\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {body, superClass} = this;\n    if (body.hasProperty(key)) {\n      return true;\n    }\n    else if (superClass && typeof superClass.hasProperty === 'function') {\n      return superClass.hasProperty(key);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Determine whether this class declaration represents a super class of\n   * the given type.\n   */\n  isSuperClassOf <X: {}> (candidate: ClassDeclaration<X> | ParameterizedClassDeclaration<*, X>) {\n    const {body, shapeID} = this;\n    let current = candidate;\n\n    while (current != null) {\n      if (current === this || current === body || current.shapeID === shapeID) {\n        return true;\n      }\n      if (current instanceof ClassDeclaration) {\n        current = current.superClass;\n      }\n      else {\n        current = current.unwrap();\n      }\n    }\n    return false;\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {name, superClass, body} = this;\n    if (withDeclaration) {\n      const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n      return `declare class ${name}${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n    }\n    else {\n      return name;\n    }\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameter from './TypeParameter';\nimport TypeParameterApplication from './TypeParameterApplication';\n\nimport {collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class PartialType<X, T> extends Type {\n  typeName: string = 'PartialType';\n  name: string;\n  type: Type<T>;\n  typeParameters: TypeParameter<X>[] = [];\n  constraints: ? TypeConstraint[];\n\n  typeParameter (id: string, bound?: Type<X>, defaultType?: Type<X>): TypeParameter<X> {\n    const target = new TypeParameter(this.context);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    this.typeParameters.push(target);\n    return target;\n  }\n\n  apply (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {constraints, type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors && constraints) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {constraints, type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (constraints && !constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return compareTypes(this.type, input);\n    }\n  }\n\n  toString (expand?: boolean): string {\n    const {type} = this;\n    return type.toString(expand);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      typeParameters: this.typeParameters,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Declaration from './Declaration';\nimport PartialType from '../types/PartialType';\nimport TypeParameterApplication from '../types/TypeParameterApplication';\nimport type {Type, TypeParameter} from '../types';\nimport type {Property} from '../types/ObjectType';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type {ClassBodyCreator} from './';\n\n\n\nexport default class ParameterizedClassDeclaration<X, O: Object> extends Declaration {\n  typeName: string = 'ParameterizedClassDeclaration';\n  bodyCreator: ClassBodyCreator<X, O>;\n  name: string;\n\n  shapeID: Symbol = Symbol();\n\n  get superClass (): ? Type<$Supertype<O>> {\n    return getPartial(this).type.superClass;\n  }\n\n  get body (): ? Type<O> {\n    return getPartial(this).type.body;\n  }\n\n  get properties(): Property<*, *>[] {\n    return getPartial(this).type.properties;\n  }\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return getPartial(this).compareWith(input);\n  }\n\n  unwrap (...typeInstances: Type<any>[]): Type<O> {\n    return getPartial(this, ...typeInstances).type;\n  }\n\n  isSuperClassOf (candidate: *) {\n    return getPartial(this).type.isSuperClassOf(candidate);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, O> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  toString (withDeclaration?: boolean) {\n    if (!withDeclaration) {\n      return this.name;\n    }\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return partial.toString(true);\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    const {superClass, body} = type;\n    const superClassName = superClass && ((typeof superClass.name === 'string' && superClass.name) || superClass.toString());\n    return `declare class ${this.name}<${items.join(', ')}>${superClassName ? ` extends ${superClassName}` : ''} ${body.toString()}`;\n  }\n\n  toJSON () {\n    return getPartial(this).toJSON();\n  }\n}\n\nfunction getPartial <X, O: Object> (parent: ParameterizedClassDeclaration<X, O>, ...typeInstances: Type<any>[]): PartialType<O> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  if (Array.isArray(body)) {\n    partial.type = context.class(parent.name, ...body);\n  }\n  else {\n    partial.type = context.class(parent.name, body);\n  }\n\n  (partial.type: $FlowFixme).shapeID = parent.shapeID;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n\n","/* @flow */\n\nimport Declaration from './Declaration';\n\nimport type {Type} from '../types';\n\nimport type Validation, {IdentifierPath, ErrorTuple} from '../Validation';\n\nexport default class ExtendsDeclaration<T> extends Declaration {\n  typeName: string = 'ExtendsDeclaration';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  unwrap () {\n    return this.type.unwrap();\n  }\n\n  toString (withDeclaration?: boolean) {\n    const {type} = this;\n    if (withDeclaration) {\n      return `extends ${type.toString()}`;\n    }\n    else {\n      return type.toString();\n    }\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport ObjectTypeProperty from './ObjectTypeProperty';\nimport ObjectTypeIndexer from './ObjectTypeIndexer';\nimport ObjectTypeCallProperty from './ObjectTypeCallProperty';\n\nimport {ClassDeclaration, ParameterizedClassDeclaration} from '../declarations';\n\nexport type Property<K: string | number, V>\n = ObjectTypeProperty<K, V>\n | ObjectTypeIndexer<K, V>\n ;\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport {\n  inValidationCycle,\n  startValidationCycle,\n  endValidationCycle,\n  inToStringCycle,\n  startToStringCycle,\n  endToStringCycle\n} from '../cyclic';\n\n\nexport default class ObjectType<T: {}> extends Type {\n  typeName: string = 'ObjectType';\n  properties: ObjectTypeProperty<$Keys<T>, any>[] = [];\n  indexers: ObjectTypeIndexer<any, any>[] = [];\n  callProperties: ObjectTypeCallProperty<any>[] = [];\n  exact: boolean = false;\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty (key: string | number): ? Property<$Keys<T>, any> {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return property;\n      }\n    }\n    return this.getIndexer(key);\n  }\n\n  setProperty (key: string | number, value: Type<*>, optional: boolean = false) {\n    const { context, properties } = this;\n    const { length } = properties;\n    const newProp = new ObjectTypeProperty(context);\n    newProp.key = key;\n    newProp.value = value;\n    newProp.optional = optional;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        properties[i] = newProp;\n        return;\n      }\n    }\n    properties.push(newProp);\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {properties} = this;\n    const {length} = properties;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.key === key) {\n        return true;\n      }\n    }\n    return this.hasIndexer(key);\n  }\n\n\n  /**\n   * Get an indexer with which matches the given key type.\n   */\n  getIndexer <K: string | number> (key: K): ? ObjectTypeIndexer<K, any> {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return indexer;\n      }\n    }\n  }\n\n  /**\n   * Determine whether an indexer exists which matches the given key type.\n   */\n  hasIndexer (key: string | number): boolean {\n    const {indexers} = this;\n    const {length} = indexers;\n    for (let i = 0; i < length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (input === null) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_CALLABLE'), this];\n      }\n    }\n    else if (typeof input !== 'object') {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    if (validation.inCycle(this, input)) {\n      return;\n    }\n    validation.startCycle(this, input);\n\n\n    if (this.indexers.length > 0) {\n      if (input instanceof Object && Array.isArray(input)) {\n        yield[path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n        return;\n      }\n      yield* collectErrorsWithIndexers(this, validation, path, input);\n    }\n    else {\n      yield* collectErrorsWithoutIndexers(this, validation, path, input);\n    }\n    if (this.exact) {\n      yield* collectErrorsExact(this, validation, path, input);\n    }\n    validation.endCycle(this, input);\n  }\n\n  accepts (input: any): boolean {\n    if (input === null) {\n      return false;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    if (hasCallProperties) {\n      if (!acceptsCallProperties(this, input)) {\n        return false;\n      }\n    }\n    else if (typeof input !== 'object') {\n      return false;\n    }\n    if (inValidationCycle(this, input)) {\n      return true;\n    }\n    startValidationCycle(this, input);\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = acceptsWithIndexers(this, input);\n    }\n    else {\n      result = acceptsWithoutIndexers(this, input);\n    }\n    if (result && this.exact) {\n      result = acceptsExact(this, input);\n    }\n    endValidationCycle(this, input);\n    return result;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ObjectType || input instanceof ClassDeclaration || input instanceof ParameterizedClassDeclaration)) {\n      return -1;\n    }\n    const hasCallProperties = this.callProperties.length > 0;\n\n    let isGreater = false;\n    if (hasCallProperties) {\n      const result = compareTypeCallProperties(this, (input: $FlowFixme));\n      if (result === -1) {\n        return -1;\n      }\n      else if (result === 1) {\n        isGreater = true;\n      }\n    }\n\n    let result;\n    if (this.indexers.length > 0) {\n      result = compareTypeWithIndexers(this, (input: $FlowFixme));\n    }\n    else {\n      result = compareTypeWithoutIndexers(this, (input: $FlowFixme));\n    }\n\n    if (result === -1) {\n      return -1;\n    }\n    else if (isGreater) {\n      return 1;\n    }\n    else {\n      return result;\n    }\n  }\n\n  toString (): string {\n    const {callProperties, properties, indexers} = this;\n    if (inToStringCycle(this)) {\n      return '$Cycle<Object>';\n    }\n    startToStringCycle(this);\n    const body = [];\n    for (let i = 0; i < callProperties.length; i++) {\n      body.push(callProperties[i].toString());\n    }\n    for (let i = 0; i < properties.length; i++) {\n      body.push(properties[i].toString());\n    }\n    for (let i = 0; i < indexers.length; i++) {\n      body.push(indexers[i].toString());\n    }\n    endToStringCycle(this);\n    if (this.exact) {\n      return `{|\\n${indent(body.join('\\n'))}\\n|}`;\n    }\n    else {\n      return `{\\n${indent(body.join('\\n'))}\\n}`;\n    }\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      callProperties: this.callProperties,\n      properties: this.properties,\n      indexers: this.indexers,\n      exact: this.exact\n    };\n  }\n}\n\nfunction acceptsCallProperties (type: ObjectType<any>, input: any): boolean {\n  const {callProperties} = type;\n  for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n    if (callProperty.accepts(input)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n\nfunction compareTypeCallProperties (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {callProperties} = type;\n  const inputCallProperties = input.callProperties;\n  let identicalCount = 0;\n  loop: for (let i = 0; i < callProperties.length; i++) {\n    const callProperty = callProperties[i];\n\n    for (let j = 0; j < inputCallProperties.length; j++) {\n      const inputCallProperty = inputCallProperties[j];\n      const result = compareTypes(callProperty, inputCallProperty);\n      if (result === 0) {\n        identicalCount++;\n        continue loop;\n      }\n      else if (result === 1) {\n        continue loop;\n      }\n    }\n    // If we got this far, nothing accepted.\n    return -1;\n  }\n  if (identicalCount === callProperties.length) {\n    return 0;\n  }\n  else {\n    return 1;\n  }\n}\n\nfunction acceptsWithIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value did not accepts any indexers.\n    return false;\n  }\n  return true;\n}\n\nfunction compareTypeWithIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {indexers, properties} = type;\n  const inputIndexers = input.indexers;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property, inputProperty);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n  }\n  loop: for (let i = 0; i < indexers.length; i++) {\n    const indexer = indexers[i];\n    for (let j = 0; j < inputIndexers.length; j++) {\n      const inputIndexer = inputIndexers[j];\n      const result = compareTypes(indexer, inputIndexer);\n      if (result === 1) {\n        isGreater = true;\n        continue loop;\n      }\n      else if (result === 0) {\n        continue loop;\n      }\n    }\n    // if we got this far, nothing accepted\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction acceptsWithoutIndexers (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    if (!property.accepts(input)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction acceptsExact (type: ObjectType<any>, input: Object): boolean {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction compareTypeWithoutIndexers (type: ObjectType<any>, input: ObjectType<any>): -1 | 0 | 1 {\n  const {properties} = type;\n  const inputProperties = input.properties;\n  let isGreater = false;\n  loop: for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    for (let j = 0; j < inputProperties.length; j++) {\n      const inputProperty = inputProperties[j];\n      if (inputProperty.key === property.key) {\n        const result = compareTypes(property.value, inputProperty.value);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 1) {\n          isGreater = true;\n        }\n        continue loop;\n      }\n    }\n    return -1;\n  }\n  return isGreater ? 1 : 0;\n}\n\n\nfunction *collectErrorsWithIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties, indexers} = type;\n  const seen = [];\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n    seen.push(property.key);\n  }\n  loop: for (const key in input) {\n    if (seen.indexOf(key) !== -1) {\n      continue;\n    }\n    const value = input[key];\n    for (let i = 0; i < indexers.length; i++) {\n      const indexer = indexers[i];\n      if (indexer.acceptsKey(key) && indexer.acceptsValue(value)) {\n        continue loop;\n      }\n    }\n\n    // if we got this far the key / value was not accepted by any indexers.\n    yield [path.concat(key), getErrorMessage('ERR_NO_INDEXER'), type];\n  }\n}\n\n\nfunction *collectErrorsWithoutIndexers (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (let i = 0; i < properties.length; i++) {\n    const property = properties[i];\n    yield* property.errors(validation, path, input);\n  }\n}\n\n\nfunction *collectErrorsExact (type: ObjectType<any>, validation: Validation<any>, path: IdentifierPath, input: Object): Generator<ErrorTuple, void, void> {\n  const {properties} = type;\n  for (const key in input) { // eslint-disable-line guard-for-in\n    if (!properties.some(property => property.key === key)) {\n      yield [path, getErrorMessage('ERR_UNKNOWN_KEY', key), type];\n    }\n  }\n}\n\nfunction indent (input: string): string {\n  const lines = input.split('\\n');\n  const {length} = lines;\n  for (let i = 0; i < length; i++) {\n    lines[i] = `  ${lines[i]}`;\n  }\n  return lines.join('\\n');\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\n\nimport ObjectType from './ObjectType';\nimport type {Property} from './ObjectType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class IntersectionType<T: {}> extends Type {\n  typeName: string = 'IntersectionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      yield* types[i].errors(validation, path, input);\n    }\n  }\n\n  /**\n   * Get a property with the given name, or undefined if it does not exist.\n   */\n  getProperty <K: string | number> (key: K): ? Property<K, any> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = length - 1; i >= 0; i--) {\n      const type = types[i];\n      if (typeof type.getProperty === 'function') {\n        const prop = type.getProperty(key);\n        if (prop) {\n          return prop;\n        }\n      }\n    }\n  }\n\n  /**\n   * Determine whether a property with the given name exists.\n   */\n  hasProperty (key: string): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (typeof type.hasProperty === 'function' && type.hasProperty(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (!type.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    let identicalCount = 0;\n    if (input instanceof IntersectionType) {\n      const inputTypes = input.types;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const result = compareTypes(type, input);\n        if (result === -1) {\n          return -1;\n        }\n        else if (result === 0) {\n          identicalCount++;\n        }\n      }\n      return identicalCount === types.length ? 0 : 1;\n    }\n  }\n\n  unwrap (): ObjectType<T> {\n    const callProperties = [];\n    const properties = [];\n    const indexers = [];\n    const {types, context} = this;\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      invariant(type instanceof ObjectType, 'Can only intersect object types');\n      callProperties.push(...type.callProperties);\n      indexers.push(...type.indexers);\n      mergeProperties(properties, type.properties);\n    }\n    return (context: any).object(\n      ...callProperties,\n      ...properties,\n      ...indexers\n    );\n  }\n\n  toString (): string {\n    return this.types.join(' & ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}\n\nfunction getPropertyIndex <K: string | number, V> (name: K, properties: ObjectTypeProperty<*, V>[]): number {\n  for (let i = 0; i < properties.length; i++) {\n    if (properties[i].name === name) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction mergeProperties <K: string | number, V> (target: ObjectTypeProperty<K, V>[], source: ObjectTypeProperty<K, V>[]): ObjectTypeProperty<K, V>[] {\n  for (let i = 0; i < source.length; i++) {\n    const typeProp = source[i];\n    const index = getPropertyIndex(typeProp.key, target);\n    if (index === -1) {\n      target.push(typeProp);\n    }\n    else {\n      target[index] = typeProp;\n    }\n  }\n  return target;\n}\n","/* @flow */\n\nimport Type from './Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class MixedType extends Type {\n  typeName: string = 'MixedType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  toString (): string {\n    return 'mixed';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumericLiteralType<T: number> extends Type {\n  typeName: string = 'NumericLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', value), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumericLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return `${this.value}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport NumericLiteralType from './NumericLiteralType';\n\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class NumberType extends Type {\n  typeName: string = 'NumberType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'number') {\n      yield [path, getErrorMessage('ERR_EXPECT_NUMBER'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'number';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof NumberType) {\n      return 0;\n    }\n    else if (input instanceof NumericLiteralType) {\n      return 1;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return 'number';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n","\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeCreator} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport TypeAlias from './TypeAlias';\nimport PartialType from './PartialType';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport {constraintsAccept} from '../typeConstraints';\n\n\nexport default class ParameterizedTypeAlias <T: Type> extends TypeAlias {\n  typeName: string = 'ParameterizedTypeAlias';\n\n  typeCreator: TypeCreator<T>;\n\n  get properties () {\n    return getPartial(this).type.properties;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    const partial = getPartial(this, ...typeInstances);\n    if (!partial.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0; // should never need this because it's taken care of by compareTypes.\n    }\n    else if (this.hasConstraints) {\n      // if we have constraints the types cannot be the same\n      return -1;\n    }\n    else {\n      return compareTypes(getPartial(this), input);\n    }\n  }\n\n  hasProperty (name: string, ...typeInstances: Type<any>[]): boolean {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name, ...typeInstances);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string, ...typeInstances: Type<any>[]): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap(...typeInstances);\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name, ...typeInstances);\n    }\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (withDeclaration?: boolean): string {\n    const partial = getPartial(this);\n    const {typeParameters} = partial;\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n\n    const {name} = this;\n    const identifier = typeParameters.length > 0\n                     ? `${name}<${items.join(', ')}>`\n                     : name\n                     ;\n\n    if (withDeclaration) {\n      return `type ${identifier} = ${partial.toString()};`;\n    }\n    else {\n      return identifier;\n    }\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <T> (parent: ParameterizedTypeAlias<T>, ...typeInstances: Type<any>[]): PartialType<T> {\n\n  const {typeCreator, context, name} = parent;\n  const partial = new PartialType(context);\n  partial.name = name;\n  partial.type = typeCreator(partial);\n  partial.constraints = parent.constraints;\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\n\nimport PartialType from './PartialType';\nimport type FunctionTypeParam from './FunctionTypeParam';\nimport type FunctionTypeRestParam from './FunctionTypeRestParam';\nimport type FunctionTypeReturn from './FunctionTypeReturn';\nimport type TypeParameter from './TypeParameter';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport type FunctionBodyCreator <P, R> = (partial: PartialType<(...params: P[]) => R>) => Array<FunctionTypeParam<P> | FunctionTypeRestParam<P> | FunctionTypeReturn<R>>;\n\n\nexport default class ParameterizedFunctionType <X, P: any, R: any> extends Type {\n  typeName: string = 'ParameterizedFunctionType';\n  bodyCreator: FunctionBodyCreator<P, R>;\n\n  get typeParameters (): TypeParameter<X>[] {\n    return getPartial(this).typeParameters;\n  }\n\n  get params (): FunctionTypeParam<P>[] {\n    return getPartial(this).type.params;\n  }\n\n  get rest (): ? FunctionTypeRestParam<P> {\n    return getPartial(this).type.rest;\n  }\n\n  get returnType (): Type<R> {\n    return getPartial(this).type.returnType;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any, ...typeInstances: Type<any>[]): Generator<ErrorTuple, void, void> {\n    yield* getPartial(this, ...typeInstances).errors(validation, path, input);\n  }\n\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean {\n    return getPartial(this, ...typeInstances).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getPartial(this), input);\n  }\n\n  acceptsParams (...args: any[]): boolean {\n    return getPartial(this).type.acceptsParams(...args);\n  }\n\n  acceptsReturn (input: any): boolean {\n    return getPartial(this).type.acceptsReturn(input);\n  }\n\n  assertParams <T> (...args: T[]): T[] {\n    return getPartial(this).type.assertParams(...args);\n  }\n\n  assertReturn <T> (input: T): T {\n    return getPartial(this).type.assertReturn(input);\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (...typeInstances: Type<any>[]): Type<(...params: P[]) => R | any> {\n    return getPartial(this, ...typeInstances).unwrap();\n  }\n\n  toString (): string {\n    const partial = getPartial(this);\n    const {type, typeParameters} = partial;\n    if (typeParameters.length === 0) {\n      return type.toString();\n    }\n    const items = [];\n    for (let i = 0; i < typeParameters.length; i++) {\n      const typeParameter = typeParameters[i];\n      items.push(typeParameter.toString(true));\n    }\n    return `<${items.join(', ')}> ${type.toString()}`;\n  }\n\n  toJSON () {\n    const partial = getPartial(this);\n    return partial.toJSON();\n  }\n}\n\nfunction getPartial <X, P, R> (parent: ParameterizedFunctionType<X, P, R>, ...typeInstances: Type<any>[]): PartialType<(...params: P[]) => R> {\n\n  const {context, bodyCreator} = parent;\n  const partial = new PartialType(context);\n  const body = bodyCreator(partial);\n  partial.type = context.function(...body);\n\n  const {typeParameters} = partial;\n  const limit = Math.min(typeInstances.length, typeParameters.length);\n  for (let i = 0; i < limit; i++) {\n    const typeParameter = typeParameters[i];\n    const typeInstance = typeInstances[i];\n    if (typeParameter.bound && typeParameter.bound !== typeInstance) {\n      // if the type parameter is already bound we need to\n      // create an intersection type with this one.\n      typeParameter.bound = context.intersect(typeParameter.bound, typeInstance);\n    }\n    else {\n      typeParameter.bound = typeInstance;\n    }\n  }\n\n  return partial;\n}\n","\nimport Type from './Type';\nimport type {TypeConstraint} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport {addConstraints, collectConstraintErrors, constraintsAccept} from '../typeConstraints';\n\nexport default class RefinementType<T> extends Type {\n  typeName: string = 'RefinementType';\n  type: Type<T>;\n  constraints: TypeConstraint[] = [];\n\n  addConstraint (...constraints: TypeConstraint[]): RefinementType<T> {\n    addConstraints(this, ...constraints);\n    return this;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {type} = this;\n    let hasErrors = false;\n    for (const error of type.errors(validation, path, input)) {\n      hasErrors = true;\n      yield error;\n    }\n    if (!hasErrors) {\n      yield* collectConstraintErrors(this, validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {type} = this;\n    if (!type.accepts(input)) {\n      return false;\n    }\n    else if (!constraintsAccept(this, input)) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input === this) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<X, T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    const {type} = this;\n    return `$Refinment<${type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringLiteralType<T: string> extends Type {\n  typeName: string = 'StringLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString (): string {\n    return JSON.stringify(this.value);\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport StringLiteralType from './StringLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class StringType extends Type {\n  typeName: string = 'StringType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    if (typeof input !== 'string') {\n      yield [path, getErrorMessage('ERR_EXPECT_STRING'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'string';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof StringLiteralType) {\n      return 1;\n    }\n    else if (input instanceof StringType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'string';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}\n\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from '../getErrorMessage';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolLiteralType<T: Symbol> extends Type {\n  typeName: string = 'SymbolLiteralType';\n  value: T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {value} = this;\n    if (input !== value) {\n      yield [path, getErrorMessage('ERR_EXPECT_EXACT_VALUE', this.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return input === this.value;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType && input.value === this.value) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return `typeof ${String(this.value)}`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      value: this.value\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport SymbolLiteralType from './SymbolLiteralType';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nexport default class SymbolType extends Type {\n  typeName: string = 'SymbolType';\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    // @flowIssue 252\n    if (typeof input !== 'symbol') {\n      yield [path, getErrorMessage('ERR_EXPECT_SYMBOL'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    return typeof input === 'symbol';\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (input instanceof SymbolLiteralType) {\n      return 1;\n    }\n    else if (input instanceof SymbolType) {\n      return 0;\n    }\n    else {\n      return -1;\n    }\n  }\n\n  toString () {\n    return 'Symbol';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName\n    };\n  }\n}","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport getErrorMessage from \"../getErrorMessage\";\n\n\n/**\n * # ThisType\n * Captures a reference to a particular instance of a class or a value,\n * and uses that value to perform an identity check.\n * In the case that `this` is undefined, any value will be permitted.\n */\nexport default class ThisType<T> extends Type {\n  typeName: string = 'ThisType';\n\n  recorded: ? T;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {recorded} = this;\n    if (input === recorded) {\n      return;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return;\n    }\n    else if (recorded != null) {\n      yield [path, getErrorMessage('ERR_EXPECT_THIS'), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {recorded} = this;\n    if (input === recorded) {\n      return true;\n    }\n    else if (typeof recorded === 'function' && input instanceof recorded) {\n      return true;\n    }\n    else if (recorded != null) {\n      return false;\n    }\n    else {\n      return true;\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    if (!(input instanceof ThisType)) {\n      return -1;\n    }\n    else if (input.recorded && this.recorded) {\n      return input.recorded === this.recorded ? 0 : -1;\n    }\n    else if (this.recorded) {\n      return 0;\n    }\n    else {\n      return 1;\n    }\n  }\n\n  /**\n   * Get the inner type.\n   */\n  unwrap (): Type<T> {\n    return this;\n  }\n\n  toString (withBinding?: boolean): string {\n    return 'this';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nexport default class TypeBox<T: any> extends Type {\n  typeName: string = 'TypeBox';\n\n  reveal: TypeRevealer<T>;\n\n  get name (): ? string {\n    return (this.type: any).name;\n  }\n\n  get type (): Type<T> {\n    const {reveal} = this;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(this)) {\n        this.context.emitWarningMessage('Failed to reveal boxed type.');\n        warnedInstances.add(this);\n      }\n      return this.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return this.context.ref(type);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this.type;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return this.type.unwrap();\n  }\n\n  toString (): string {\n    return this.type.toString();\n  }\n\n  toJSON () {\n    return this.type.toJSON();\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport TypeParameterApplication from './TypeParameterApplication';\nimport compareTypes from '../compareTypes';\n\nconst warnedMissing = {};\n\nexport default class TypeReference<T: any> extends Type {\n  typeName: string = 'TypeReference';\n  name: string;\n\n  get type (): Type<T> {\n    const {context, name} = this;\n    const type = context.get(name);\n    if (!type) {\n      if (!warnedMissing[name]) {\n        context.emitWarningMessage(`Cannot resolve type: ${name}`);\n        warnedMissing[name] = true;\n      }\n      return (context.any(): any);\n    }\n    return type;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.type, input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = this;\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return (this.type.unwrap(): any);\n  }\n\n  toString (): string {\n    return this.name;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      name: this.name\n    };\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport compareTypes from '../compareTypes';\nimport type {TypeRevealer} from './';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\nimport type ObjectTypeProperty from './ObjectTypeProperty';\n\nimport TypeParameterApplication from './TypeParameterApplication';\n\nconst warnedInstances = new WeakSet();\n\nconst RevealedName = Symbol('RevealedName');\nconst RevealedValue = Symbol('RevealedValue');\n\nexport default class TypeTDZ<T: any> extends Type {\n  typeName: string = 'TypeTDZ';\n\n  reveal: TypeRevealer<T>;\n\n  // @flowIssue 252\n  [RevealedName]: ? string = undefined;\n\n  // @flowIssue 252\n  [RevealedValue]: ? Type<T> = undefined;\n\n  get name (): ? string {\n    let name = (this: any)[RevealedName];\n    if (!name) {\n      name = (getRevealed(this): any).name;\n    }\n    return name;\n  }\n\n  set name (value: string) {\n    (this: any)[RevealedName] = value;\n  }\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* getRevealed(this).errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return getRevealed(this).accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(getRevealed(this), input);\n  }\n\n  apply <X> (...typeInstances: Type<X>[]): TypeParameterApplication<T> {\n    const target = new TypeParameterApplication(this.context);\n    target.parent = getRevealed(this);\n    target.typeInstances = typeInstances;\n    return target;\n  }\n\n  /**\n   * Get the inner type or value.\n   */\n  unwrap (): Type<T> {\n    return getRevealed(this).unwrap();\n  }\n\n  hasProperty (name: string): boolean {\n    const inner = this.unwrap();\n    if (inner && typeof inner.hasProperty === 'function') {\n      return inner.hasProperty(name);\n    }\n    else {\n      return false;\n    }\n  }\n\n  getProperty (name: string): ? ObjectTypeProperty<any> {\n    const inner = this.unwrap();\n    if (inner && typeof inner.getProperty === 'function') {\n      return inner.getProperty(name);\n    }\n  }\n\n  toString (): string {\n    return getRevealed(this).toString();\n  }\n\n  toJSON () {\n    return getRevealed(this).toJSON();\n  }\n}\n\nfunction getRevealed <T: any> (container: TypeTDZ<T>): Type<T> {\n  const existing = (container: $FlowIssue<252>)[RevealedValue];\n  if (existing) {\n    return existing;\n  }\n  else {\n    const {reveal} = container;\n    const type = reveal();\n    if (!type) {\n      if (!warnedInstances.has(container)) {\n        const name = (container: any)[RevealedName];\n        if (name) {\n          container.context.emitWarningMessage(`Failed to reveal type called \"${name}\" in Temporal Dead Zone.`);\n        }\n        else {\n          container.context.emitWarningMessage('Failed to reveal unknown type in Temporal Dead Zone.');\n        }\n        warnedInstances.add(container);\n      }\n      return container.context.mixed();\n    }\n    else if (!(type instanceof Type)) {\n      // we got a boxed reference to something like a class\n      return container.context.ref(type);\n    }\n    return type;\n  }\n}\n","/* @flow */\n\nimport Type from './Type';\nimport getErrorMessage from \"../getErrorMessage\";\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nimport compareTypes from '../compareTypes';\n\nexport default class UnionType<T> extends Type {\n  typeName: string = 'UnionType';\n  types: Type<T>[] = [];\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return;\n      }\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', this.toString()), this];\n  }\n\n  accepts (input: any): boolean {\n    const {types} = this;\n    const {length} = types;\n    for (let i = 0; i < length; i++) {\n      const type = types[i];\n      if (type.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const types = this.types;\n    if (input instanceof UnionType) {\n      const inputTypes = input.types;\n      let identicalCount = 0;\n      loop: for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        for (let j = 0; j < inputTypes.length; j++) {\n          const result = compareTypes(type, inputTypes[i]);\n          if (result === 0) {\n            identicalCount++;\n            continue loop;\n          }\n          else if (result === 1) {\n            continue loop;\n          }\n        }\n        // if we got this far then nothing accepted this type.\n        return -1;\n      }\n\n      if (identicalCount === types.length) {\n        return 0;\n      }\n      else {\n        return 1;\n      }\n    }\n    else {\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (compareTypes(type, input) >= 0) {\n          return 1;\n        }\n      }\n      return -1;\n    }\n  }\n\n  toString (): string {\n    const {types} = this;\n    const normalized = new Array(types.length);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i];\n      if (type.typeName === 'FunctionType' || type.typeName === 'ParameterizedFunctionType') {\n        normalized[i] = `(${type.toString()})`;\n      }\n      else {\n        normalized[i] = type.toString();\n      }\n    }\n    return normalized.join(' | ');\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      types: this.types\n    };\n  }\n}","/* @flow */\n\nimport primitiveTypes from './primitiveTypes';\n\nimport type TypeContext from './TypeContext';\n\nimport {\n  NullLiteralType,\n  NumberType,\n  BooleanType,\n  SymbolType,\n  StringType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  VoidType\n} from './types';\n\n\nexport default function registerPrimitiveTypes (t: TypeContext): TypeContext {\n  primitiveTypes.null = Object.freeze(new NullLiteralType(t));\n  primitiveTypes.empty = Object.freeze(new EmptyType(t));\n  primitiveTypes.number = Object.freeze(new NumberType(t));\n  primitiveTypes.boolean = Object.freeze(new BooleanType(t));\n  primitiveTypes.string = Object.freeze(new StringType(t));\n  primitiveTypes.symbol = Object.freeze(new SymbolType(t));\n  primitiveTypes.any = Object.freeze(new AnyType(t));\n  primitiveTypes.mixed = Object.freeze(new MixedType(t));\n  primitiveTypes.void = Object.freeze(new VoidType(t));\n  primitiveTypes.existential = Object.freeze(new ExistentialType(t));\n  return t;\n}","/* @flow */\nimport getErrorMessage from './getErrorMessage';\n\nimport invariant from './invariant';\n\nimport {Type} from './types';\n\nimport type TypeContext from './TypeContext';\nimport type Validation, {ErrorTuple, IdentifierPath} from './Validation';\n\nexport default function registerBuiltinTypeConstructors (t: TypeContext): TypeContext {\n\n  t.declareTypeConstructor({\n    name: 'Date',\n    impl: Date,\n    typeName: 'DateType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n      if (!(input instanceof Date)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Date'), this];\n      }\n      else if (isNaN(input.getTime())) {\n        yield [path, getErrorMessage('ERR_INVALID_DATE'), this];\n      }\n    },\n    accepts (input): boolean {\n      return input instanceof Date && !isNaN(input.getTime());\n    },\n    compareWith(input) {\n      if (input.typeName === 'DateType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Date): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Promise',\n    impl: Promise,\n    typeName: 'PromiseType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, futureType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(futureType, 'Must specify type parameter for Promise.');\n      const {context} = this;\n      if (!context.checkPredicate('Promise', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_PROMISE', futureType), this];\n      }\n    },\n    accepts (input): boolean {\n      const {context} = this;\n      return context.checkPredicate('Promise', input);\n    },\n    compareWith(input) {\n      if (input.typeName === 'PromiseType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: any): Type<any>[] {\n      return [];\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Map',\n    impl: Map,\n    typeName: 'MapType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, keyType?: Type<any>, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(keyType, 'Must specify two type parameters for Map.');\n      invariant(valueType, 'Must specify two type parameters for Map.');\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Map'), this];\n        return;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key)) {\n          yield [path, getErrorMessage('ERR_EXPECT_KEY_TYPE', keyType), this];\n        }\n\n        yield* valueType.errors(validation, path.concat(key), value);\n      }\n    },\n    accepts (input, keyType: Type<any>, valueType: Type<any>): boolean {\n      const {context} = this;\n      if (!context.checkPredicate('Map', input)) {\n        return false;\n      }\n      for (const [key, value] of input) {\n        if (!keyType.accepts(key) || !valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'MapType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Map<*, *>): Type<any>[] {\n      const keyTypes = [];\n      const valueTypes = [];\n      loop: for (const [key, value] of input) {\n        findKey: {\n          for (let i = 0; i < keyTypes.length; i++) {\n            const type = keyTypes[i];\n            if (type.accepts(key)) {\n              break findKey;\n            }\n          }\n          keyTypes.push(t.typeOf(key));\n        }\n\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      const typeInstances = [];\n\n      if (keyTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (keyTypes.length === 1) {\n        typeInstances.push(keyTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...keyTypes));\n      }\n\n      if (valueTypes.length === 0) {\n        typeInstances.push(t.existential());\n      }\n      else if (valueTypes.length === 1) {\n        typeInstances.push(valueTypes[0]);\n      }\n      else {\n        typeInstances.push(t.union(...valueTypes));\n      }\n\n      return typeInstances;\n    }\n  });\n\n  t.declareTypeConstructor({\n    name: 'Set',\n    impl: Set,\n    typeName: 'SetType',\n    *errors (validation: Validation<any>, path: IdentifierPath, input: any, valueType?: Type<any>): Generator<ErrorTuple, void, void> {\n      invariant(valueType, 'Must specify type parameter for Set.');\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        yield [path, getErrorMessage('ERR_EXPECT_INSTANCEOF', 'Set'), this];\n        return;\n      }\n      for (const value of input) {\n        yield* valueType.errors(validation, path, value);\n      }\n    },\n    accepts (input, valueType) {\n      const {context} = this;\n      if (!context.checkPredicate('Set', input)) {\n        return false;\n      }\n      for (const value of input) {\n        if (!valueType.accepts(value)) {\n          return false;\n        }\n      }\n      return true;\n    },\n    compareWith(input) {\n      if (input.typeName === 'SetType') {\n        return 0;\n      }\n      return -1;\n    },\n    inferTypeParameters (input: Set<*>): Type<any>[] {\n      const valueTypes = [];\n      loop: for (const value of input) {\n        for (let i = 0; i < valueTypes.length; i++) {\n          const type = valueTypes[i];\n          if (type.accepts(value)) {\n            continue loop;\n          }\n        }\n        valueTypes.push(t.typeOf(value));\n      }\n      if (valueTypes.length === 0) {\n        return [t.existential()];\n      }\n      else if (valueTypes.length === 1) {\n        return [valueTypes[0]];\n      }\n      else {\n        return [t.union(...valueTypes)];\n      }\n    }\n  });\n\n  return t;\n}","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nexport default function registerTypePredicates (context: TypeContext) {\n  context.setPredicate('Array', (input: any) => Array.isArray(input));\n  context.setPredicate('Map', (input: any) => input instanceof Map);\n  context.setPredicate('Set', (input: any) => input instanceof Set);\n  context.setPredicate('Promise', (input: any) => {\n    if (input instanceof Promise) {\n      return true;\n    } else {\n      return input !== null\n        && (typeof input === 'object' || typeof input === 'function')\n        && typeof input.then === 'function'\n        ;\n    }\n  });\n}\n","/* @flow */\n\nimport type TypeContext from './TypeContext';\n\nimport type {\n  Type,\n  ArrayType,\n  ObjectType\n} from './types';\n\ntype Inferred = Map<Object, Type<any>>;\n\nexport class TypeInferer {\n  context: TypeContext;\n\n  constructor (context: TypeContext) {\n    this.context = context;\n  }\n\n  infer <T> (input: T): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    const inferred = new Map();\n    return this.inferComplex(input, inferred);\n  }\n\n  inferInternal <T> (input: T, inferred: Inferred): Type<T> {\n    const primitive = this.inferPrimitive(input);\n    if (primitive) {\n      return primitive;\n    }\n    return this.inferComplex(input, inferred);\n  }\n\n  inferPrimitive <T> (input: T): ? Type<T> {\n    const {context} = this;\n    if (input === null) {\n      return (context.null(): any);\n    }\n    else if (input === undefined) {\n      return (context.void(): any);\n    }\n    else if (typeof input === 'number') {\n      return (context.number(): any);\n    }\n    else if (typeof input === 'boolean') {\n      return (context.boolean(): any);\n    }\n    else if (typeof input === 'string') {\n      return (context.string(): any);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return context.symbol((input: any));\n    }\n    else {\n      return undefined;\n    }\n  }\n\n  inferComplex <T> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n\n    if (typeof input === 'function') {\n      return (this.inferFunction(input, inferred): any);\n    }\n    else if (input !== null && typeof input === 'object') {\n      return (this.inferObject(input, inferred): any);\n    }\n    else {\n      return (context.any(): any);\n    }\n  }\n\n  inferFunction <T: Function> (input: T, inferred: Inferred): Type<T> {\n    const {context} = this;\n    const {length} = input;\n    const body = new Array(length + 1);\n    for (let i = 0; i < length; i++) {\n      body[i] = context.param(\n        String.fromCharCode(97 + i),\n        context.existential()\n      );\n    }\n    body[length] = context.return(context.existential());\n    return (context.fn(...body): any);\n  }\n\n  inferObject <T: Object> (input: T, inferred: Inferred): Type<T> {\n    const existing = inferred.get(input);\n    if (existing) {\n      return existing;\n    }\n    const {context} = this;\n    let type;\n\n    // Temporarily create a box for this type to catch cyclical references.\n    // Nested references to this object will receive the boxed type.\n    const box = context.box(() => type);\n    inferred.set(input, box);\n\n    if (context.checkPredicate('Array', input)) {\n      type = this.inferArray((input: any), inferred);\n    }\n    else if (!(input instanceof Object)) {\n      type = this.inferDict(input, inferred);\n    }\n    else if (input.constructor !== Object) {\n      const handler = context.getTypeConstructor(input.constructor);\n      if (handler) {\n        const typeParameters = handler.inferTypeParameters(input);\n        type = handler.apply(...typeParameters);\n      }\n      else {\n        type = context.ref(input.constructor);\n      }\n    }\n    else {\n      const body = [];\n      for (const key in input) { // eslint-disable-line\n        const value = input[key];\n        body.push(context.property(key, this.inferInternal(value, inferred)));\n      }\n      type = context.object(...body);\n    }\n\n    // Overwrite the box with the real value.\n    inferred.set(input, type);\n    return (type: any);\n  }\n\n  inferDict <T: Object> (input: T, inferred: Inferred): ObjectType<T> {\n    const numericIndexers = [];\n    const stringIndexers = [];\n    loop: for (const key in input) { // eslint-disable-line\n      const value = input[key];\n      const types = isNaN(+key) ? stringIndexers : numericIndexers;\n      for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        if (type.accepts(value)) {\n          continue loop;\n        }\n      }\n      types.push(this.inferInternal(value, inferred));\n    }\n\n    const {context} = this;\n    const body = [];\n    if (numericIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          numericIndexers[0]\n        )\n      );\n    }\n    else if (numericIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'index',\n          context.number(),\n          context.union(...numericIndexers)\n        )\n      );\n    }\n\n    if (stringIndexers.length === 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          stringIndexers[0]\n        )\n      );\n    }\n    else if (stringIndexers.length > 1) {\n      body.push(\n        context.indexer(\n          'key',\n          context.string(),\n          context.union(...stringIndexers)\n        )\n      );\n    }\n\n    return context.object(...body);\n  }\n\n  inferArray <T> (input: T[], inferred: Inferred): ArrayType<T> {\n    const {context} = this;\n    const types = [];\n    const values = [];\n    const {length} = input;\n    loop: for (let i = 0; i < length; i++) {\n      const item = input[i];\n      const inferredType = this.inferInternal(item, inferred);\n      for (let j = 0; j < types.length; j++) {\n        const type = types[j];\n        if (type.accepts(item) && inferredType.accepts(values[j])) {\n          continue loop;\n        }\n      }\n      types.push(inferredType);\n      values.push(item);\n    }\n    if (types.length === 0) {\n      return (context.array(context.any()): any);\n    }\n    else if (types.length === 1) {\n      return context.array(types[0]);\n    }\n    else {\n      return context.array(context.union(...types));\n    }\n  }\n\n}\n\nexport default TypeInferer;","/* @flow */\n\nimport makeError from './makeError';\n\nimport type ObjectType from './types/ObjectType';\n\nexport type PropType<T: {}> = (props: T, propName: string, componentName: string) => ? Error;\n\nexport type PropTypeDict<T: {}> = $ObjMap<T, <V>(v: V) => PropType<V>>;\n\nexport default function makeReactPropTypes <T: {}> (objectType: ObjectType<T>): PropTypeDict<T> {\n  const output = {};\n  if (!objectType.properties) {\n    return output;\n  }\n  for (const property of objectType.properties) {\n    output[property.key] = (props, propName, componentName) => {\n      return makeError(property, props);\n    };\n  }\n  return output;\n}","/* @flow */\nimport {stringifyPath, resolvePath} from '../Validation';\n\nimport type Validation from '../Validation';\n\nconst delimiter = '\\n-------------------------------------------------\\n\\n';\n\nexport default function makeWarningMessage <T> (validation: Validation<T>): ? string {\n  if (!validation.hasErrors()) {\n    return;\n  }\n  const {input, context} = validation;\n  const collected = [];\n  for (const [path, message, expectedType] of validation.errors) {\n    const expected = expectedType ? expectedType.toString() : \"*\";\n    const actual = context.typeOf(resolvePath(input, path)).toString();\n\n    const field = stringifyPath(validation.path.concat(path));\n\n\n    collected.push(\n      `${field} ${message}\\n\\nExpected: ${expected}\\n\\nActual: ${actual}\\n`\n    );\n  }\n  return `Warning: ${collected.join(delimiter)}`;\n}\n","/* @flow */\n\nimport UnionType from './types/UnionType';\nimport compareTypes from './compareTypes';\n\nimport AnyType from './types/AnyType';\nimport MixedType from './types/MixedType';\nimport ExistentialType from './types/ExistentialType';\n\nimport type TypeContext from './TypeContext';\nimport type Type from './types/Type';\n\n\nexport default function makeUnion <T> (context: TypeContext, types: Type<T>[]): Type<T> {\n  const length = types.length;\n  const merged = [];\n  for (let i = 0; i < length; i++) {\n    const type = types[i];\n    if (type instanceof AnyType || type instanceof MixedType || type instanceof ExistentialType) {\n      return (type: $FlowFixme);\n    }\n    if (type instanceof UnionType) {\n      mergeUnionTypes(merged, type.types);\n    }\n    else {\n      merged.push(type);\n    }\n  }\n  const union = new UnionType(context);\n  union.types = merged;\n  return union;\n}\n\nfunction mergeUnionTypes (aTypes: Type<any>[], bTypes: Type<any>[]): void {\n  loop: for (let i = 0; i < bTypes.length; i++) {\n    const bType = bTypes[i];\n    for (let j = 0; j < aTypes.length; j++) {\n      const aType = aTypes[j];\n      if (compareTypes(aType, bType) !== -1) {\n        continue loop;\n      }\n    }\n    aTypes.push(bType);\n  }\n}","/* @flow */\n\nimport type Type from './types/Type';\n\ntype ValueDescriptor<T> = {\n  writable: boolean;\n  initializer?: () => T;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\ntype AccessorDescriptor<T> = {\n  get: () => ? T;\n  set: (value: T) => void;\n  enumerable: boolean;\n  configurable: boolean;\n};\n\nexport type Descriptor<T>\n = AccessorDescriptor<T>\n | ValueDescriptor<T>\n ;\n\ntype TypeSource<T>\n = (() => Type<T>)\n | Type<T>\n ;\n\nexport function makePropertyDescriptor <O: {} | Function, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: Descriptor<T>, shouldAssert: boolean): ? Descriptor<T> {\n  if (typeof descriptor.get === 'function' && typeof descriptor.set === 'function') {\n    return augmentExistingAccessors(typeSource, input, propertyName, (descriptor: $FlowIssue<AccessorDescriptor<T>>), shouldAssert);\n  }\n  else {\n    return propertyToAccessor(typeSource, input, propertyName, (descriptor: $FlowIssue<ValueDescriptor<T>>), shouldAssert);\n  }\n}\n\nfunction makePropertyName (name: string): string {\n  return `_flowRuntime$${name}`;\n}\n\nfunction getClassName (input: Function | Object): string {\n  if (typeof input === 'function') {\n    return input.name || '[Class anonymous]';\n  }\n  else if (typeof input.constructor === 'function') {\n    return getClassName(input.constructor);\n  }\n  else {\n    return '[Class anonymous]';\n  }\n}\n\nfunction resolveType <T> (receiver: any, typeSource: TypeSource<T>): Type<T> {\n  if (typeof typeSource === 'function') {\n    return typeSource.call(receiver);\n  }\n  else {\n    return typeSource;\n  }\n}\n\nfunction propertyToAccessor <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: ValueDescriptor<T>, shouldAssert: boolean): AccessorDescriptor<T> {\n  const safeName = makePropertyName(propertyName);\n  const className = getClassName(input);\n  const {initializer, writable, ...config} = descriptor; // eslint-disable-line no-unused-vars\n\n  const propertyPath = [className, propertyName];\n\n  return {\n    ...config,\n    type: 'accessor',\n    get (): ? T {\n      if (safeName in this) {\n        return (this: any)[safeName];\n      }\n      else if (initializer) {\n        const type = resolveType(this, typeSource);\n        const value = initializer.call(this);\n        const context = type.context;\n        context.check(type, value, 'Default value for property', propertyPath);\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n        return value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: undefined\n        });\n      }\n    },\n    set (value: T): void {\n      const type = resolveType(this, typeSource);\n      const context = type.context;\n      if (shouldAssert) {\n        context.assert(type, value, 'Property', propertyPath);\n      }\n      else {\n        context.warn(type, value, 'Property', propertyPath);\n      }\n      if (safeName in this) {\n        this[safeName] = value;\n      }\n      else {\n        Object.defineProperty(this, safeName, {\n          writable: true,\n          value: value\n        });\n      }\n    }\n  };\n}\n\nfunction augmentExistingAccessors <O: {}, T> (typeSource: TypeSource<T>, input: O, propertyName: string, descriptor: AccessorDescriptor<T>, shouldAssert: boolean) {\n\n  const className = getClassName(input);\n  const propertyPath = [className, propertyName];\n\n  const originalSetter = descriptor.set;\n\n  descriptor.set = function set (value: T): void {\n    const type = resolveType(this, typeSource);\n    const context = type.context;\n    if (shouldAssert) {\n      context.assert(type, value, 'Property', propertyPath);\n    }\n    else {\n      context.warn(type, value, 'Property', propertyPath);\n    }\n    originalSetter.call(this, value);\n  };\n\n}\n\n","/* @flow */\n\nimport Type from './types/Type';\n\nimport {TypeSymbol} from './symbols';\n\nexport type Decorator<T> = (input: T) => T;\n\ndeclare function annotateValue <T> (type: Type<T>): Decorator<T>;\ndeclare function annotateValue <T> (input: T, type: Type<T>): T; // eslint-disable-line no-redeclare\n\nexport default function annotateValue (input, type?) { // eslint-disable-line no-redeclare\n  if (type instanceof Type) {\n    input[TypeSymbol] = type;\n    return input;\n  }\n  else {\n    const type = input;\n    return (input) => {\n      input[TypeSymbol] = type;\n      return input;\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// If A and B are object types, $Diff<A,B> is the type of objects that have\n// properties defined in A, but not in B.\n// Properties that are defined in both A and B are allowed too.\n\nexport default class $DiffType<A: {}, B: {}> extends Type<$Diff<A, B>> {\n  typeName: string = '$DiffType';\n\n  aType: Type<A>;\n  bType: Type<B>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      yield* property.errors(validation, path.concat(property.key), input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {aType, bType} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      if (!property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Diff<A, B>> {\n    let {aType, bType} = this;\n    aType = aType.unwrap();\n    bType = bType.unwrap();\n    invariant(aType instanceof ObjectType && bType instanceof ObjectType, 'Can only $Diff object types.');\n    const properties = aType.properties;\n    const args = [];\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      if (bType.hasProperty(property.key)) {\n        continue;\n      }\n      args.push(property);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Diff<${this.aType.toString()}, ${this.bType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      aType: this.aType,\n      bType: this.bType\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $FlowFixMeType extends Type<any> {\n  typeName: string = '$FlowFixMeType';\n\n  *errors (validation: Validation<any>, input: any, path: IdentifierPath = []): Generator<ErrorTuple, void, void> {\n\n  }\n\n  accepts (input: any): boolean {\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return 1;\n  }\n\n  unwrap (): Type<any> {\n    return this;\n  }\n\n  toString (): string {\n    return '$FlowFixMe';\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $KeysType<T: {}> extends Type<$Keys<T>> {\n  typeName: string = '$KeysType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return;\n      }\n    }\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      keys[i] = properties[i].key;\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', keys.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (input === property.key) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Keys<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Keys<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const keys = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      keys[i] = context.literal(property.key);\n    }\n    return this.context.union(...keys);\n  }\n\n  toString (): string {\n    return `$Keys<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys and values in an object.\n\nexport default class $ObjMapiType<O: {}, M: Mapper> extends Type<$ObjMapi<O, M>> {\n  typeName: string = '$ObjMapiType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key), prop.value);\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMapi<O, M>> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key), prop.value)\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMapi<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport ObjectTypeProperty from '../types/ObjectTypeProperty';\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the keys in an object.\n\nexport default class $ObjMapType<O: {}, M: Mapper> extends Type<$ObjMap<O, M>> {\n  typeName: string = '$ObjMapType';\n\n  object: Type<O>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      yield* returnType.errors(validation, path.concat(prop.key), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const returnType = applied.invoke(context.literal(prop.key));\n\n      const value = input[prop.key];\n      if (!returnType.accepts(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$ObjMap<O, M>> {\n\n    let {object, mapper, context} = this;\n    const target = object.unwrap();\n    invariant(target instanceof ObjectType, 'Target must be an object type.');\n\n    const args = [];\n\n    for (const prop: ObjectTypeProperty<*, *> of target.properties) {\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(context.property(\n        prop.key,\n        applied.invoke(context.literal(prop.key))\n      ));\n    }\n\n    return context.object(...args);\n  }\n\n  toString (): string {\n    return `$ObjMap<${this.object.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The type of the named object property\n\nexport default class $PropertyType<O: {}, P: string | number | Symbol> extends Type {\n  typeName: string = '$PropertyType';\n\n  object: Type<O>;\n\n  property: P;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.unwrap().errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.unwrap().accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<*> {\n    const {object, property} = this;\n    const unwrapped = object.unwrap();\n    invariant(typeof unwrapped.getProperty === 'function', 'Can only use $PropertyType on Objects.');\n    return unwrapped.getProperty(property).unwrap();\n  }\n\n  toString (): string {\n    return `$PropertyType<${this.object.toString()}, ${String(this.property)}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      object: this.object,\n      property: this.property\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// An object of type $Shape<T> does not have to have all of the properties\n// that type T defines. But the types of the properties that it does have\n// must accepts the types of the same properties in T.\n\nexport default class $ShapeType<T> extends Type<$Shape<T>> {\n  typeName: string = '$ShapeType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {type} = this;\n\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      yield [path, getErrorMessage('ERR_EXPECT_OBJECT'), this];\n      return;\n    }\n\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property) {\n        continue;\n      }\n      yield* property.errors(validation, path, input);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {type} = this;\n    if (input === null || (typeof input !== 'object' && typeof input !== 'function')) {\n      return false;\n    }\n    type = type.unwrap();\n    invariant(typeof type.getProperty === 'function', 'Can only $Shape<T> object types.');\n    for (const key in input) { // eslint-disable-line guard-for-in\n      const property = type.getProperty(key);\n      if (!property || !property.accepts(input)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Shape<T>> {\n    let {type} = this;\n    type = type.unwrap();\n    const context = this.context;\n    invariant(type instanceof ObjectType, 'Can only $Shape<T> object types.');\n    const properties = type.properties;\n    const args = new Array(properties.length);\n    for (let i = 0; i < properties.length; i++) {\n      const property = properties[i];\n      args[i] = context.property(property.key, property.value, true);\n    }\n    return this.context.object(...args);\n  }\n\n  toString (): string {\n    return `$Shape<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any subtype of T\n\nexport default class $SubType<T> extends Type<$Subtype<T>> {\n  typeName: string = '$SubType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(input, path);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Subtype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Subtype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport compareTypes from '../compareTypes';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// Any, but at least T.\n\nexport default class $SuperType<T> extends Type<$Supertype<T>> {\n  typeName: string = '$SuperType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    yield* this.type.errors(validation, path, input);\n  }\n\n  accepts (input: any): boolean {\n    return this.type.accepts(input);\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Supertype<T>> {\n    return this.type;\n  }\n\n  toString (): string {\n    return `$Supertype<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport TupleType from '../types/TupleType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\n\nimport FunctionType from '../types/FunctionType';\n\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\ntype Mapper = <V: any, R: any> (v: V) => R;\n\n// Map over the values in a tuple.\n\nexport default class $TupleMapType<T: [], M: Mapper> extends Type<$TupleMap<T, M>> {\n  typeName: string = '$TupleMapType';\n\n  tuple: Type<T>;\n  mapper: Type<M>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      yield [path, getErrorMessage('ERR_EXPECT_ARRAY'), this];\n      return;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      const expected = applied.invoke(type);\n      const value = input[i];\n      yield* expected.errors(validation, path.concat(i), value);\n    }\n  }\n\n  accepts (input: any): boolean {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be a tuple type.');\n\n    if (!context.checkPredicate('Array', input)) {\n      return false;\n    }\n\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      if (!applied.invoke(type).accepts(input[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$TupleMap<T, M>> {\n    let {tuple, mapper, context} = this;\n    const target = tuple.unwrap();\n    invariant(target instanceof TupleType, 'Target must be an tuple type.');\n\n    const args = [];\n    for (let i = 0; i < target.types.length; i++) {\n      const type = target.types[i];\n      const applied = mapper.unwrap();\n      invariant(applied instanceof FunctionType, 'Mapper must be a function type.');\n\n      args.push(applied.invoke(type).unwrap().unwrap());\n    }\n\n    return context.tuple(...args);\n  }\n\n  toString (): string {\n    return `$TupleMap<${this.tuple.toString()}, ${this.mapper.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      tuple: this.tuple,\n      mapper: this.mapper\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport ObjectType from '../types/ObjectType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport invariant from '../invariant';\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\n// The set of keys of T.\n\nexport default class $ValuesType<T: {}> extends Type<$Values<T>> {\n  typeName: string = '$ValuesType';\n\n  type: Type<T>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return;\n      }\n    }\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      values[i] = properties[i].value.toString();\n    }\n    yield [path, getErrorMessage('ERR_NO_UNION', values.join(' | ')), this];\n  }\n\n  accepts (input: any): boolean {\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      if (property.value.accepts(input)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    return compareTypes(this.unwrap(), input);\n  }\n\n  unwrap (): Type<$Values<T>> {\n    const context = this.context;\n    const type = this.type.unwrap();\n    invariant(type instanceof ObjectType, 'Can only $Values<T> object types.');\n\n    const properties = type.properties;\n    const length = properties.length;\n    const values = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const property = properties[i];\n      values[i] = property.value;\n    }\n    return context.union(...values);\n  }\n\n  toString (): string {\n    return `$Values<${this.type.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      type: this.type\n    };\n  }\n}","/* @flow */\n\nimport Type from '../types/Type';\nimport GenericType from '../types/GenericType';\nimport getErrorMessage from '../getErrorMessage';\nimport compareTypes from '../compareTypes';\n\nimport type TypeContext from '../TypeContext';\n\nimport type Validation, {ErrorTuple, IdentifierPath} from '../Validation';\n\nfunction checkGenericType (context: TypeContext, expected: GenericType, input: Function) {\n  const {impl} = expected;\n  if (typeof impl !== 'function') {\n    // There is little else we can do here, so accept anything.\n    return true;\n  }\n  else if (impl === input || impl.isPrototypeOf(input)) {\n    return true;\n  }\n\n  const annotation = context.getAnnotation(impl);\n  if (annotation == null) {\n    return false;\n  }\n  else {\n    return checkType(context, annotation, input);\n  }\n}\n\nfunction checkType (context: TypeContext, expected: Type<*>, input: Function) {\n  const annotation = context.getAnnotation(input);\n  if (annotation != null) {\n    const result = compareTypes(expected, annotation);\n    return result !== -1;\n  }\n  return true;\n}\n\n\nexport default class ClassType<T> extends Type {\n  typeName: string = 'ClassType';\n\n  instanceType: Type<*>;\n\n  *errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void> {\n\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n      return;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    const isValid = (\n      expectedType instanceof GenericType\n      ? checkGenericType(context, expectedType, input)\n      : checkType(context, expectedType, input)\n    );\n    if (!isValid) {\n      yield [path, getErrorMessage('ERR_EXPECT_CLASS', instanceType.toString()), this];\n    }\n  }\n\n  accepts (input: any): boolean {\n    const {instanceType, context} = this;\n    if (typeof input !== 'function') {\n      return false;\n    }\n    const expectedType = (\n      instanceType.typeName === 'ClassDeclaration'\n      ? instanceType\n      : instanceType.unwrap()\n    );\n    if (expectedType instanceof GenericType) {\n      return checkGenericType(context, expectedType, input);\n    }\n    else {\n      return checkType(context, expectedType, input);\n    }\n  }\n\n  compareWith (input: Type<any>): -1 | 0 | 1 {\n    const {instanceType} = this;\n    if (input instanceof ClassType) {\n      return compareTypes(instanceType, input.instanceType);\n    }\n    return -1;\n  }\n\n  toString (): string {\n    return `Class<${this.instanceType.toString()}>`;\n  }\n\n  toJSON () {\n    return {\n      typeName: this.typeName,\n      instanceType: this.instanceType\n    };\n  }\n}","/* @flow */\n\nimport TypeInferrer from './TypeInferrer';\nimport primitiveTypes from './primitiveTypes';\nimport invariant from './invariant';\n\nimport Validation from './Validation';\n\nimport makeReactPropTypes from './makeReactPropTypes';\n\nimport makeJSONError from './errorReporting/makeJSONError';\nimport makeTypeError from './errorReporting/makeTypeError';\nimport makeWarningMessage from './errorReporting/makeWarningMessage';\n\nimport makeUnion from './makeUnion';\nimport compareTypes from './compareTypes';\nimport {makePropertyDescriptor} from './classDecorators';\n\nimport {flowIntoTypeParameter} from './types/TypeParameter';\n\nimport annotateValue from './annotateValue';\n\nimport type {PropTypeDict} from './makeReactPropTypes';\nimport type {IdentifierPath, ErrorTuple} from './Validation';\n\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType\n} from './types';\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport {\n  $DiffType,\n  $FlowFixMeType,\n  $KeysType,\n  $ObjMapiType,\n  $ObjMapType,\n  $PropertyType as _$PropertyType,\n  $ShapeType,\n  $SubType,\n  $SuperType,\n  $TupleMapType,\n  $ValuesType,\n  ClassType\n} from './flowTypes';\n\nimport {\n  ParentSymbol,\n  NameRegistrySymbol,\n  ModuleRegistrySymbol,\n  CurrentModuleSymbol,\n  TypeConstructorRegistrySymbol,\n  TypeParametersSymbol,\n  InferrerSymbol,\n  TypePredicateRegistrySymbol,\n  TypeSymbol\n} from './symbols';\n\nimport type {\n  TypeConstraint,\n  TypeCreator,\n  TypeRevealer,\n  FunctionBodyCreator,\n  ApplicableType,\n  ValidFunctionBody,\n  ObjectPropertyDict,\n  ValidObjectBody\n} from './types';\n\nimport type {\n  ClassBodyCreator,\n  ValidClassBody\n} from './declarations';\n\nexport type TypeConstructorConfig = {\n  name: string;\n  impl?: Function;\n  typeName: string;\n  compareWith?: (Type<any>) => -1 | 0 | 1;\n  errors (validation: Validation<any>, path: IdentifierPath, input: any): Generator<ErrorTuple, void, void>;\n  accepts (input: any, ...typeInstances: Type<any>[]): boolean;\n  inferTypeParameters (input: any): Type<any>[];\n};\n\nexport type TypePredicate = (input: any) => boolean;\n\ntype NameRegistry = {\n  [name: string]: Type<any> | Class<TypeConstructor<any>>;\n};\n\ntype TypePredicateRegistry = {\n  [name: string]: TypePredicate;\n};\n\ntype ModuleRegistry = {\n  [name: string]: ModuleDeclaration;\n};\n\ntype TypeConstructorRegistry = Map<Function, Class<TypeConstructor<any>>>;\n\nexport type MatchClause<P, R> = (...params: P[]) => R;\nexport type PatternMatcher<P, R> = (...params: P[]) => R;\n\nexport type CheckMode\n  = 'assert'\n  | 'warn'\n  ;\n\n\n/**\n * Keeps track of invalid references in order to prevent\n * multiple warnings.\n */\nconst warnedInvalidReferences: WeakSet<any> = new WeakSet();\n\nexport default class TypeContext {\n\n  /**\n   * Calls to `t.check(...)` will call either\n   * `t.assert(...)` or `t.warn(...)` depending on this setting.\n   */\n  mode: CheckMode = 'assert';\n\n  // @flowIssue 252\n  [ParentSymbol]: ? TypeContext;\n\n  // @flowIssue 252\n  [NameRegistrySymbol]: NameRegistry = {};\n\n  // @flowIssue 252\n  [TypePredicateRegistrySymbol]: TypePredicateRegistry = {};\n\n  // @flowIssue 252\n  [TypeConstructorRegistrySymbol]: TypeConstructorRegistry = new Map();\n\n  // @flowIssue 252\n  [InferrerSymbol]: TypeInferrer = new TypeInferrer(this);\n\n  // @flowIssue 252\n  [ModuleRegistrySymbol]: ModuleRegistry = {};\n\n  // @flowIssue 252\n  [CurrentModuleSymbol]: ? ModuleDeclaration;\n\n  get TypeParametersSymbol (): typeof TypeParametersSymbol {\n    return TypeParametersSymbol;\n  }\n\n\n  makeJSONError <T> (validation: Validation<T>): ? Array<Object> {\n    return makeJSONError(validation);\n  }\n\n  makeTypeError <T> (validation: Validation<T>): ? TypeError {\n    return makeTypeError(validation);\n  }\n\n  createContext (): TypeContext {\n    const context = new TypeContext();\n    // @flowIssue 252\n    context[ParentSymbol] = this;\n    return context;\n  }\n\n  typeOf <T> (input: T): Type<T> {\n\n    const annotation = this.getAnnotation(input);\n    if (annotation) {\n      if (typeof input === 'function' && (annotation instanceof ClassDeclaration || annotation instanceof ParameterizedClassDeclaration)) {\n        return this.Class(annotation);\n      }\n      return annotation;\n    }\n    // @flowIssue 252\n    const inferrer = this[InferrerSymbol];\n    (inferrer: TypeInferrer);\n\n    return inferrer.infer(input);\n  }\n\n  compareTypes (a: Type<any>, b: Type<any>): -1 | 0 | 1 {\n    return compareTypes(a, b);\n  }\n\n  get (name: string, ...propertyNames: string[]): ? Type<any> {\n    // @flowIssue 252\n    const item = this[NameRegistrySymbol][name];\n    if (item != null) {\n      let current = typeof item === 'function'\n                  ? new item(this)\n                  : item\n                  ;\n      for (let i = 0; i < propertyNames.length; i++) {\n        const propertyName = propertyNames[i];\n        if (typeof current.getProperty !== 'function') {\n          return;\n        }\n        current = current.getProperty(propertyName);\n        if (!current) {\n          return;\n        }\n        current = current.unwrap();\n      }\n      return current;\n    }\n    // @flowIssue 252\n    const parent = this[ParentSymbol];\n    if (parent) {\n      const fromParent = parent.get(name, ...propertyNames);\n      if (fromParent) {\n        return fromParent;\n      }\n    }\n\n    // if we got this far, see if we have a global type with this name.\n    if (typeof global[name] === 'function') {\n      const target = new GenericType(this);\n      target.name = name;\n      target.impl = global[name];\n      // @flowIssue 252\n      this[NameRegistrySymbol][name] = target;\n      return target;\n    }\n  }\n\n  /**\n   * Get the predicate for a given type name.\n   * e.g. `t.getPredicate('Array')`.\n   */\n  getPredicate (name: string): ? TypePredicate {\n    const item: ? TypePredicate = (this: any)[TypePredicateRegistrySymbol][name];\n    if (item) {\n      return item;\n    }\n    const parent: ? TypeContext = (this: any)[ParentSymbol];\n    if (parent) {\n      return parent.getPredicate(name);\n    }\n  }\n\n  /**\n   * Set the predicate for a given type name.\n   * This can be used to customise the behaviour of things like Array\n   * detection or allowing Thenables in place of the global Promise.\n   */\n  setPredicate (name: string, predicate: TypePredicate) {\n    (this: any)[TypePredicateRegistrySymbol][name] = predicate;\n  }\n\n  /**\n   * Check the given value against the named predicate.\n   * Returns false if no such predicate exists.\n   * e.g. `t.checkPredicate('Array', [1, 2, 3])`\n   */\n  checkPredicate (name: string, input: any): boolean {\n    const predicate = this.getPredicate(name);\n    if (predicate) {\n      return predicate(input);\n    }\n    else {\n      return false;\n    }\n  }\n\n  /**\n   * Returns a decorator for a function or object with the given type.\n   */\n  decorate (type: (() => Type<any>) | Type<any>, shouldAssert?: boolean): * {\n    if (shouldAssert == null) {\n      shouldAssert = this.mode === 'assert';\n    }\n    return (input: Object | Function, propertyName?: string, descriptor?: Object): * => {\n      if (descriptor && typeof propertyName === 'string') {\n        return makePropertyDescriptor(type, input, propertyName, descriptor, Boolean(shouldAssert));\n      }\n      else {\n        invariant(typeof type !== 'function', 'Cannot decorate an object or function as a method.');\n        return this.annotate(input, type);\n      }\n    };\n  }\n\n  /**\n   * Annotates an object or function with the given type.\n   * If a type is specified as the sole argument, returns a\n   * function which can decorate classes or functions with the given type.\n   */\n  annotate <T> (input: Type<T> | T, type?: Type<T>) {\n    if (type === undefined) {\n      return annotateValue(input);\n    }\n    else {\n      return annotateValue(input, type);\n    }\n  }\n\n  getAnnotation <T> (input: T): ? Type<T> {\n    if ((input !== null && typeof input === 'object') || typeof input === 'function') {\n      // @flowIssue 252\n      return input[TypeSymbol];\n    }\n  }\n\n  hasAnnotation (input: any): boolean {\n    if (input == null) {\n      return false;\n    }\n    else {\n      return input[TypeSymbol] ? true : false;\n    }\n  }\n\n  setAnnotation <T: Object | Function> (input: T, type: Type<T>): T {\n    input[TypeSymbol] = type;\n    return input;\n  }\n\n  type <T> (name: string, type: Type<T> | TypeCreator<Type<T>>): TypeAlias<T> | ParameterizedTypeAlias<T> {\n    if (typeof type === 'function') {\n      const target = new ParameterizedTypeAlias(this);\n      target.name = name;\n      target.typeCreator = type;\n      return target;\n    }\n    else {\n      const target = new TypeAlias(this);\n      target.name = name;\n      target.type = type;\n      return target;\n    }\n  }\n\n  declare <T: any, D: ModuleDeclaration | TypeDeclaration<T> | VarDeclaration<T> | ClassDeclaration<T>> (name: string | D, type?: Type<T> | TypeCreator<Type<T>>): D | TypeDeclaration<T> {\n\n    if (name instanceof Declaration) {\n      type = name;\n      name = type.name;\n    }\n    else if (name instanceof TypeAlias) {\n      type = name;\n      name = type.name;\n    }\n    if (typeof type === 'function') {\n      type = this.type(name, type);\n    }\n    if (type instanceof ModuleDeclaration) {\n      const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n      moduleRegistry[name] = type;\n      return type;\n    }\n    else {\n      invariant(typeof name === 'string', 'Name must be a string');\n      invariant(type instanceof Type, 'Type must be supplied to declaration');\n      const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n      if (type instanceof Declaration) {\n        nameRegistry[name] = type;\n        return type;\n      }\n      else if (type instanceof TypeAlias || type instanceof ParameterizedTypeAlias) {\n        const target = new TypeDeclaration(this);\n        target.name = name;\n        target.typeAlias = type;\n        nameRegistry[name] = target;\n        return target;\n      }\n      else {\n        const target = this.var(name, type);\n        nameRegistry[name] = target;\n        return target;\n      }\n    }\n  }\n\n  *declarations (): Generator<[string, Type<any> | TypeConstructor<any>], void, void> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n    for (const key in nameRegistry) { // eslint-disable-line guard-for-in\n      yield [key, nameRegistry[key]];\n    }\n  }\n\n  *modules (): Generator<ModuleDeclaration, void, void> {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    for (const key in moduleRegistry) { // eslint-disable-line guard-for-in\n      yield moduleRegistry[key];\n    }\n  }\n\n  import (moduleName: string): ? ModuleDeclaration {\n    const moduleRegistry: ModuleRegistry = (this: $FlowIssue<252>)[ModuleRegistrySymbol];\n    if (moduleRegistry[moduleName]) {\n      return moduleRegistry[moduleName];\n    }\n    const [head] = moduleName.split('/');\n    const module = moduleRegistry[head];\n    if (module) {\n      return module.import(moduleName);\n    }\n    const parent = (this: $FlowIssue<252>)[ParentSymbol];\n    if (parent) {\n      return parent.import(moduleName);\n    }\n  }\n\n  declareTypeConstructor ({name, impl, typeName, errors, accepts, inferTypeParameters, compareWith}: TypeConstructorConfig): TypeConstructor<any> {\n    const nameRegistry: NameRegistry = (this: $FlowIssue<252>)[NameRegistrySymbol];\n\n    if (nameRegistry[name]) {\n      this.emitWarningMessage(`Redeclaring type: ${name}, this may be unintended.`);\n    }\n\n    const target = new TypeConstructor(this);\n    target.name = name;\n    target.typeName = typeName;\n    target.impl = impl;\n    target.errors = errors;\n    target.accepts = accepts;\n    target.inferTypeParameters = inferTypeParameters;\n    if (typeof compareWith === 'function') {\n      target.compareWith = compareWith;\n    }\n\n    nameRegistry[name] = target;\n\n    if (typeof impl === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      if (handlerRegistry.has(impl)) {\n        this.emitWarningMessage(`A type handler already exists for the given implementation of ${name}.`);\n      }\n      handlerRegistry.set(impl, target);\n    }\n    return target;\n  }\n\n  getTypeConstructor (impl: Function): ? TypeConstructor<any> {\n    // @flowIssue 252\n    const handlerRegistry = this[TypeConstructorRegistrySymbol];\n    (handlerRegistry: TypeConstructorRegistry);\n\n    return handlerRegistry.get(impl);\n  }\n\n  literal <T: void | null | boolean | number | string | Symbol> (input: T): Type<T> {\n    if (input === undefined) {\n      return this.void();\n    }\n    else if (input === null) {\n      return this.null();\n    }\n    else if (typeof input === 'boolean') {\n      return this.boolean(input);\n    }\n    else if (typeof input === 'number') {\n      return this.number(input);\n    }\n    else if (typeof input === 'string') {\n      return this.string(input);\n    }\n    // @flowIssue 252\n    else if (typeof input === 'symbol') {\n      return this.symbol(input);\n    }\n    else {\n      return this.typeOf(input);\n    }\n  }\n\n  null (): NullLiteralType {\n    return primitiveTypes.null;\n  }\n\n  nullable <T> (type: Type<T>): NullableType<? T> {\n    const target = new NullableType(this);\n    target.type = type;\n    return target;\n  }\n\n  existential (): ExistentialType {\n    return primitiveTypes.existential;\n  }\n\n\n  empty (): EmptyType {\n    return primitiveTypes.empty;\n  }\n\n  any (): AnyType {\n    return primitiveTypes.any;\n  }\n\n  mixed (): MixedType {\n    return primitiveTypes.mixed;\n  }\n\n  void (): VoidType {\n    return primitiveTypes.void;\n  }\n\n  this <T> (input?: T): ThisType<T> {\n    const target = new ThisType(this);\n    if (input !== undefined) {\n      target.recorded = input;\n    }\n    return target;\n  }\n\n  number <T: number> (input?: T): NumberType | NumericLiteralType<T> {\n    if (input !== undefined) {\n      const target = new NumericLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.number;\n    }\n  }\n\n  boolean <T: boolean> (input?: T): BooleanType | BooleanLiteralType<T> {\n    if (input !== undefined) {\n      const target = new BooleanLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.boolean;\n    }\n  }\n\n  string <T: string> (input?: T): StringType | StringLiteralType<T> {\n    if (input !== undefined) {\n      const target = new StringLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.string;\n    }\n  }\n\n  symbol <T: Symbol> (input?: T): SymbolType | SymbolLiteralType<T> {\n    if (input !== undefined) {\n      const target = new SymbolLiteralType(this);\n      target.value = input;\n      return target;\n    }\n    else {\n      return primitiveTypes.symbol;\n    }\n  }\n\n  typeParameter <T> (id: string, bound?: Type<T>, defaultType?: Type<T>): TypeParameter<T> {\n    const target = new TypeParameter(this);\n    target.id = id;\n    target.bound = bound;\n    target.default = defaultType;\n    return target;\n  }\n\n  flowInto <T> (typeParameter: TypeParameter<T>): FlowIntoType<T> {\n    return flowIntoTypeParameter(typeParameter);\n  }\n\n  /**\n   * Bind the type parameters for the parent class of the given instance.\n   */\n  bindTypeParameters <T: {}> (subject: T, ...typeInstances: Type<any>[]): T {\n    const instancePrototype = Object.getPrototypeOf(subject);\n    // @flowIssue\n    const parentPrototype = instancePrototype && Object.getPrototypeOf(instancePrototype);\n    // @flowIssue\n    const parentClass = parentPrototype && parentPrototype.constructor;\n\n    if (!parentClass) {\n      this.emitWarningMessage('Could not bind type parameters for non-existent parent class.');\n      return subject;\n    }\n    // @flowIssue 252\n    const typeParametersPointer = parentClass[TypeParametersSymbol];\n\n    if (typeParametersPointer) {\n      const typeParameters = subject[typeParametersPointer];\n      const keys = Object.keys(typeParameters);\n      const length = Math.min(keys.length, typeInstances.length);\n      for (let i = 0; i < length; i++) {\n        const typeParam = typeParameters[keys[i]];\n        typeParam.bound = typeInstances[i];\n      }\n    }\n    return subject;\n  }\n\n  module (name: string, body: (context: TypeContext) => any): ModuleDeclaration {\n    const target = new ModuleDeclaration(this);\n    target.name = name;\n    const innerContext = this.createContext();\n    // @flowIssue 252\n    innerContext[ParentSymbol] = this;\n    // @flowIssue 252\n    innerContext[CurrentModuleSymbol] = target;\n\n    target.innerContext = innerContext;\n    body(innerContext);\n    return target;\n  }\n\n  moduleExports <T> (type: Type<T>): ModuleExportsDeclaration<T> {\n    const currentModule: ModuleDeclaration = (this: $FlowIssue<252>)[CurrentModuleSymbol];\n    if (!currentModule) {\n      throw new Error('Cannot declare module.exports outside of a module.');\n    }\n    const target = new ModuleExportsDeclaration(this);\n    target.type = type;\n    currentModule.moduleExports = target;\n    return target;\n  }\n\n  var <T> (name: string, type: Type<T>): VarDeclaration<T> {\n    const target = new VarDeclaration(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  class <X, O: {}> (name: string, head?: ClassBodyCreator<X, O> | ValidClassBody<X, O>, ...tail: Array<ValidClassBody<X, O>>): ClassDeclaration<O> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedClassDeclaration(this);\n      target.name = name;\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new ClassDeclaration(this);\n    target.name = name;\n    if (head != null) {\n      tail.unshift(head);\n    }\n    const {length} = tail;\n    const properties = [];\n    let body;\n\n    for (let i = 0; i < length; i++) {\n      const item = tail[i];\n      if (item instanceof ObjectTypeProperty || item instanceof ObjectTypeIndexer) {\n        properties.push(item);\n      }\n      else if (item instanceof ObjectType) {\n        invariant(!body, 'Class body must only be declared once.');\n        body = item;\n      }\n      else if (item instanceof ExtendsDeclaration) {\n        invariant(!target.superClass, 'Classes can only have one super class.');\n        target.superClass = item;\n      }\n      else if (item != null && typeof item === 'object' && !(item instanceof Type)) {\n        for (const propertyName in item) { // eslint-disable-line\n          properties.push(this.property(propertyName, (item: any)[propertyName]));\n        }\n      }\n      else {\n        throw new Error('ClassDeclaration cannot contain the given type directly.');\n      }\n    }\n    if (!body) {\n      body = new ObjectType(this);\n    }\n    if (properties.length) {\n      body.properties.push(...properties);\n    }\n    target.body = body;\n    return target;\n  }\n\n  extends <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): ExtendsDeclaration<T> {\n    const target = new ExtendsDeclaration(this);\n    target.type = this.ref(subject, ...typeInstances);\n    return target;\n  }\n\n  fn <X, P, R> (head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    return this.function(head, ...tail);\n  }\n\n  function <X, P, R> (head: ? FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ParameterizedFunctionType<X, P, R> | FunctionType<P, R> {\n    if (typeof head === 'function') {\n      const target = new ParameterizedFunctionType(this);\n      target.bodyCreator = head;\n      return target;\n    }\n    const target = new FunctionType(this);\n    if (head != null) {\n      tail.unshift(head);\n      const {length} = tail;\n      for (let i = 0; i < length; i++) {\n        const item = tail[i];\n        if (item instanceof FunctionTypeParam) {\n          target.params.push(item);\n        }\n        else if (item instanceof FunctionTypeRestParam) {\n          target.rest = item;\n        }\n        else if (item instanceof FunctionTypeReturn) {\n          target.returnType = item;\n        }\n        else {\n          throw new Error('FunctionType cannot contain the given type directly.');\n        }\n      }\n    }\n    if (!target.returnType) {\n      target.returnType = this.any();\n    }\n    return target;\n  }\n\n  param <T> (name: string, type: Type<T>, optional: boolean = false): FunctionTypeParam<T> {\n    const target = new FunctionTypeParam(this);\n    target.name = name;\n    target.type = type;\n    target.optional = optional;\n    return target;\n  }\n\n  rest <T> (name: string, type: Type<T>): FunctionTypeRestParam<T> {\n    const target = new FunctionTypeRestParam(this);\n    target.name = name;\n    target.type = type;\n    return target;\n  }\n\n  return <T> (type: Type<T>): FunctionTypeReturn<T> {\n    const target =  new FunctionTypeReturn(this);\n    target.type = type;\n    return target;\n  }\n\n  generator <Y, R, N> (yieldType: Type<Y>, returnType?: Type<R>, nextType?: Type<N>): GeneratorType<Y, R, N> {\n    const target = new GeneratorType(this);\n    target.yieldType = yieldType;\n    target.returnType = returnType || this.any();\n    target.nextType = nextType || this.any();\n    return target;\n  }\n\n  object <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    if (head != null && typeof head === 'object' && !(head instanceof Type)) {\n      for (const propertyName in head) { // eslint-disable-line\n        target.properties.push(this.property(propertyName, head[propertyName]));\n      }\n    }\n    else {\n      let body;\n      if (head) {\n        body = [head, ...tail];\n      }\n      else {\n        body = tail;\n      }\n      const {length} = body;\n      for (let i = 0; i < length; i++) {\n        const item = body[i];\n        if (item instanceof ObjectTypeProperty) {\n          target.properties.push(item);\n        }\n        else if (item instanceof ObjectTypeIndexer) {\n          target.indexers.push(item);\n        }\n        else if (item instanceof ObjectTypeCallProperty) {\n          target.callProperties.push(item);\n        }\n        else {\n          throw new Error('ObjectType cannot contain the given type directly.');\n        }\n      }\n    }\n    return target;\n  }\n\n  exactObject <T: {}> (head: ? ValidObjectBody<T> | $ObjMap<T, <V>(v: V) => Type<V>>, ...tail: ValidObjectBody<T>[]): ObjectType<T> {\n    const object = this.object(head, ...tail);\n    object.exact = true;\n    return object;\n  }\n\n  callProperty <T> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const target = new ObjectTypeCallProperty(this);\n    target.value = value;\n    return target;\n  }\n\n  property <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const target = new ObjectTypeProperty(this);\n    target.key = key;\n    if (value instanceof Type) {\n      target.value = value;\n    }\n    else {\n      target.value = this.object(value);\n    }\n    target.optional = optional;\n    return target;\n  }\n\n  indexer <K, V> (id: string, key: Type<K>, value: Type<V>): ObjectTypeIndexer<K, V> {\n    const target = new ObjectTypeIndexer(this);\n    target.id = id;\n    target.key = key;\n    target.value = value;\n    return target;\n  }\n\n  method <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const target = new ObjectTypeProperty(this);\n    target.key = name;\n    target.value = this.function(head, ...tail);\n    return target;\n  }\n\n  staticCallProperty <T: Function> (value: Type<T>): ObjectTypeCallProperty<T> {\n    const prop = this.callProperty(value);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticProperty <K: string | number, V> (key: K, value: Type<V> | ObjectPropertyDict<{}>, optional: boolean = false): ObjectTypeProperty<K, V> {\n    const prop = this.property(key, value, optional);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  staticMethod <K: string | number, X, P, R> (name: K, head: FunctionBodyCreator<X, P, R> | ValidFunctionBody<X, P, R>, ...tail: Array<ValidFunctionBody<X, P, R>>): ObjectTypeProperty<K, (...params: P[]) => R> {\n    const prop = this.method(name, head, ...tail);\n    (prop: $FlowIssue).static = true;\n    return prop;\n  }\n\n  spread <T> (...types: Type<T>[]): ObjectType<T> {\n    const target = new ObjectType(this);\n    for (let i = 0; i < types.length; i++) {\n      const type = types[i].unwrap();\n      if (Array.isArray(type.callProperties)) {\n        target.callProperties.push(...type.callProperties);\n      }\n      if (Array.isArray(type.indexers)) {\n        target.indexers.push(...type.indexers);\n      }\n      if (Array.isArray(type.properties)) {\n        for (let j = 0; j < type.properties.length; j++) {\n          const prop = type.properties[j];\n          invariant(prop instanceof ObjectTypeProperty);\n          target.setProperty(prop.key, prop.value, prop.optional);\n        }\n      }\n    }\n    return target;\n  }\n\n  tuple <T> (...types: Type<T>[]): TupleType<any> {\n    const target = new TupleType(this);\n    target.types = types;\n    return target;\n  }\n\n  array <T> (elementType?: Type<T>): ArrayType<T> {\n    const target = new ArrayType(this);\n    target.elementType = elementType || this.any();\n    return target;\n  }\n\n  union <T> (...types: Type<T>[]): Type<T> {\n    return makeUnion(this, types);\n  }\n\n  intersect <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    const target = new IntersectionType(this);\n    target.types = types;\n    return target;\n  }\n\n  intersection <T: {}> (...types: Type<T>[]): IntersectionType<T> {\n    return this.intersect(...types);\n  }\n\n  box <T> (reveal: TypeRevealer<T>): TypeBox<T> {\n    const box = new TypeBox(this);\n    box.reveal = reveal;\n    return box;\n  }\n\n  tdz <T> (reveal: TypeRevealer<T>, name?: string): TypeTDZ<T> {\n    const tdz = new TypeTDZ(this);\n    tdz.reveal = reveal;\n    tdz.name = name;\n    return tdz;\n  }\n\n  ref <T, P> (subject: string | ApplicableType<T> | Function, ...typeInstances: Type<P>[]): Type<T | any> {\n    let target;\n    if (typeof subject === 'string') {\n      // try and eagerly resolve the reference\n      target = this.get(subject);\n      if (!target) {\n        // defer dereferencing for now\n        target = new TypeReference(this);\n        target.name = subject;\n      }\n    }\n    else if (typeof subject === 'function') {\n      // @flowIssue 252\n      const handlerRegistry = this[TypeConstructorRegistrySymbol];\n      (handlerRegistry: TypeConstructorRegistry);\n\n      // see if we have a dedicated TypeConstructor for this.\n      target = handlerRegistry.get(subject);\n\n      if (!target) {\n        // just use a generic type handler.\n        target = new GenericType(this);\n        target.impl = subject;\n        target.name = subject.name;\n      }\n\n    }\n    else if (subject instanceof Type) {\n      target = subject;\n    }\n    else {\n      if (subject == null || typeof subject !== 'object') {\n        this.emitWarningMessage(`Could not reference the given type, try t.typeOf(value) instead. (got ${String(subject)})`);\n      }\n      else if (!warnedInvalidReferences.has(subject)) {\n        this.emitWarningMessage('Could not reference the given type, try t.typeOf(value) instead.');\n        warnedInvalidReferences.add(subject);\n      }\n      return this.any();\n    }\n\n    if (typeInstances.length) {\n      invariant(typeof target.apply === 'function', `Cannot apply non-applicable type: ${target.typeName}.`);\n      return target.apply(...typeInstances);\n    }\n    else {\n      return target;\n    }\n  }\n\n  validate <T> (type: Type<T>, input: any, prefix: string = '', path?: string[]): Validation<T> {\n    const validation = new Validation(this, input);\n    if (path) {\n      validation.path.push(...path);\n    }\n    else if (typeof type.name === 'string') {\n      validation.path.push(type.name);\n    }\n    validation.prefix = prefix;\n    validation.errors = Array.from(type.errors(validation, [], input));\n    return validation;\n  }\n\n  check <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    if (this.mode === 'assert') {\n      return this.assert(type, input, prefix, path);\n    }\n    else {\n      return this.warn(type, input, prefix, path);\n    }\n  }\n\n  assert <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const error = this.makeTypeError(validation);\n    if (error) {\n      throw error;\n    }\n    return input;\n  }\n\n  warn <T, V: T | any> (type: Type<T>, input: V, prefix: string = '', path?: string[]): V {\n    const validation = this.validate(type, input, prefix, path);\n    const message = makeWarningMessage(validation);\n    if (typeof message === 'string') {\n      this.emitWarningMessage(message);\n    }\n    return input;\n  }\n\n  /**\n   * Emits a warning message, using `console.warn()` by default.\n   */\n  emitWarningMessage (message: string): void {\n    console.warn('flow-runtime:', message);\n  }\n\n  propTypes <T: {}> (type: Type<T>): PropTypeDict<T> {\n    return makeReactPropTypes((type.unwrap(): $FlowIgnore));\n  }\n\n  match <P, R> (...args: Array<P | MatchClause<P, R>>): R {\n    const clauses: any = args.pop();\n    if (!Array.isArray(clauses)) {\n      throw new Error('Invalid pattern, last argument must be an array.');\n    }\n    (clauses: MatchClause<P, R>[]);\n    const pattern = this.pattern(...clauses);\n    return pattern(...args);\n  }\n\n  pattern <P, R> (...clauses: MatchClause<P, R>[]): PatternMatcher<P, R> {\n    const {length} = clauses;\n    const tests: Array<true | FunctionType<P, R> | ParameterizedFunctionType<any, P, R>> = new Array(length);\n    for (let i = 0; i < length; i++) {\n      const clause = clauses[i];\n      const annotation = this.getAnnotation(clause);\n      if (!annotation) {\n        if (i !== length - 1) {\n          throw new Error(`Invalid Pattern - found unannotated function in position ${i}, default clauses must be last.`);\n        }\n        tests[i] = true;\n      }\n      else {\n        invariant(annotation instanceof FunctionType || annotation instanceof ParameterizedFunctionType, 'Pattern clauses must be annotated functions.');\n        tests[i] = annotation;\n      }\n    }\n    return (...args: P[]): R => {\n      for (let i = 0; i < tests.length; i++) {\n        const test = tests[i];\n        const clause = clauses[i];\n        if (test === true) {\n          return clause(...args);\n        }\n        else if (test.acceptsParams(...args)) {\n          return clause(...args);\n        }\n      }\n      const error = new TypeError('Value did not match any of the candidates.');\n      error.name = 'RuntimeTypeError';\n      throw error;\n    };\n  }\n\n  wrapIterator <T> (type: Type<T>): (input: Iterable<T>) => Generator<T, void, void> {\n    const t = this;\n    return function* wrappedIterator (input: Iterable<T>): Generator<T, void, void> {\n      for (const item of input) {\n        yield t.check(type, item);\n      }\n    };\n  }\n\n  refinement <T> (type: Type<T>, ...constraints: TypeConstraint[]): RefinementType<T> {\n    const target = new RefinementType(this);\n    target.type = type;\n    target.addConstraint(...constraints);\n    return target;\n  }\n\n  $exact <T> (type: Type<T>): ObjectType<T> {\n    const target = new ObjectType(this);\n    type = type.unwrap();\n    if (Array.isArray(type.callProperties)) {\n      target.callProperties.push(...type.callProperties);\n    }\n    if (Array.isArray(type.indexers)) {\n      target.indexers.push(...type.indexers);\n    }\n    if (Array.isArray(type.properties)) {\n      target.properties.push(...type.properties);\n    }\n    target.exact = true;\n    return target;\n  }\n\n  $diff <A: {}, B: {}> (aType: Type<A>, bType: Type<B>): $DiffType<A, B> {\n    const target = new $DiffType(this);\n    target.aType = aType;\n    target.bType = bType;\n    return target;\n  }\n\n  $flowFixMe (): $FlowFixMeType {\n    return new $FlowFixMeType(this);\n  }\n\n  $keys <T: {}> (type: Type<T>): $KeysType<T> {\n    const target = new $KeysType(this);\n    target.type = type;\n    return target;\n  }\n\n  $objMap <O: {}, K: $Keys<O>, M: (k: K) => any> (object: Type<O>, mapper: Type<M>): $ObjMapType<O, M> {\n    const target = new $ObjMapType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $objMapi <O: {}, K: $Keys<O>, M: (k: K, v: any) => any> (object: Type<O>, mapper: Type<M>): $ObjMapiType<O, M> {\n    const target = new $ObjMapiType(this);\n    target.object = object;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $propertyType <O: {}, P: string | number | Symbol> (object: Type<O>, property: P | Type<P>): _$PropertyType<O, P> {\n    const target = new _$PropertyType(this);\n    target.object = object;\n    if (property instanceof Type) {\n      const unwrapped = property.unwrap();\n      target.property = (unwrapped: any).value;\n    }\n    else {\n      target.property = property;\n    }\n    return target;\n  }\n\n  $shape <T: {}> (type: Type<T>): $ShapeType<T> {\n    const target = new $ShapeType(this);\n    target.type = type;\n    return target;\n  }\n\n  $subtype <T: {}> (type: Type<T>): $SubType<T> {\n    const target = new $SubType(this);\n    target.type = type;\n    return target;\n  }\n\n  $supertype <T: {}> (type: Type<T>): $SuperType<T> {\n    const target = new $SuperType(this);\n    target.type = type;\n    return target;\n  }\n\n  $tupleMap <T: [], M: (v: *) => *> (tuple: Type<T>, mapper: Type<M>): $TupleMapType<T, M> {\n    const target = new $TupleMapType(this);\n    target.tuple = tuple;\n    target.mapper = mapper;\n    return target;\n  }\n\n  $values <T: {}> (type: Type<T>): $ValuesType<T> {\n    const target = new $ValuesType(this);\n    target.type = type;\n    return target;\n  }\n\n  Class <T: {}> (instanceType: Type<T>): ClassType<T> {\n    const target = new ClassType(this);\n    target.instanceType = instanceType;\n    return target;\n  }\n}\n\n","/* @flow */\n\nimport registerPrimitiveTypes from './registerPrimitiveTypes';\nimport registerBuiltinTypeConstructors from './registerBuiltins';\nimport registerTypePredicates from './registerTypePredicates';\n\nimport TypeContext from './TypeContext';\n\nlet globalContext;\nif (typeof global !== 'undefined' && typeof global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== 'undefined') {\n  globalContext = global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__;\n}\nelse {\n  globalContext = new TypeContext();\n  registerPrimitiveTypes(globalContext);\n  registerBuiltinTypeConstructors(globalContext);\n  registerTypePredicates(globalContext);\n  if (typeof global !== 'undefined') {\n    global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ = globalContext;\n  }\n}\n\n\nexport default globalContext;","/* @flow */\n\nimport globalContext from './globalContext';\n\nimport {\n  Type,\n  TypeParameter,\n  TypeBox,\n  TypeReference,\n  TypeTDZ,\n  ParameterizedTypeAlias,\n  TypeAlias,\n  TypeConstructor,\n  GenericType,\n  NullLiteralType,\n  NumberType,\n  NumericLiteralType,\n  BooleanType,\n  BooleanLiteralType,\n  SymbolType,\n  SymbolLiteralType,\n  StringType,\n  StringLiteralType,\n  ArrayType,\n  ObjectType,\n  ObjectTypeCallProperty,\n  ObjectTypeIndexer,\n  ObjectTypeProperty,\n  FlowIntoType,\n  FunctionType,\n  ParameterizedFunctionType,\n  PartialType,\n  FunctionTypeParam,\n  FunctionTypeRestParam,\n  FunctionTypeReturn,\n  GeneratorType,\n  ExistentialType,\n  AnyType,\n  MixedType,\n  EmptyType,\n  NullableType,\n  ThisType,\n  TupleType,\n  UnionType,\n  IntersectionType,\n  VoidType,\n  RefinementType,\n  TypeParameterApplication\n} from './types';\n\n\nimport {\n  Declaration,\n  TypeDeclaration,\n  VarDeclaration,\n  ModuleDeclaration,\n  ModuleExportsDeclaration,\n  ClassDeclaration,\n  ParameterizedClassDeclaration,\n  ExtendsDeclaration\n} from './declarations';\n\nimport TypeContext from './TypeContext';\n\nfunction v (thing) {\n  return { value: thing }\n}\n\nif (typeof global !== 'undefined' && global.__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__ !== globalContext) {\n  Object.defineProperties(globalContext, {\n    TypeContext: v(TypeContext),\n    Type: v(Type),\n    TypeBox: v(TypeBox),\n    TypeParameter: v(TypeParameter),\n    TypeReference: v(TypeReference),\n    TypeTDZ: v(TypeTDZ),\n    ParameterizedTypeAlias: v(ParameterizedTypeAlias),\n    TypeAlias: v(TypeAlias),\n    TypeConstructor: v(TypeConstructor),\n    GenericType: v(GenericType),\n    NullLiteralType: v(NullLiteralType),\n    NumberType: v(NumberType),\n    NumericLiteralType: v(NumericLiteralType),\n    BooleanType: v(BooleanType),\n    BooleanLiteralType: v(BooleanLiteralType),\n    SymbolType: v(SymbolType),\n    SymbolLiteralType: v(SymbolLiteralType),\n    StringType: v(StringType),\n    StringLiteralType: v(StringLiteralType),\n    ArrayType: v(ArrayType),\n    ObjectType: v(ObjectType),\n    ObjectTypeCallProperty: v(ObjectTypeCallProperty),\n    ObjectTypeIndexer: v(ObjectTypeIndexer),\n    ObjectTypeProperty: v(ObjectTypeProperty),\n    FunctionType: v(FunctionType),\n    FunctionTypeParam: v(FunctionTypeParam),\n    FunctionTypeRestParam: v(FunctionTypeRestParam),\n    FunctionTypeReturn: v(FunctionTypeReturn),\n    ParameterizedFunctionType: v(ParameterizedFunctionType),\n    PartialType: v(PartialType),\n    RefinementType: v(RefinementType),\n    TypeParameterApplication: v(TypeParameterApplication),\n    GeneratorType: v(GeneratorType),\n    ExistentialType: v(ExistentialType),\n    FlowIntoType: v(FlowIntoType),\n    AnyType: v(AnyType),\n    MixedType: v(MixedType),\n    EmptyType: v(EmptyType),\n    NullableType: v(NullableType),\n    ThisType: v(ThisType),\n    TupleType: v(TupleType),\n    UnionType: v(UnionType),\n    IntersectionType: v(IntersectionType),\n    VoidType: v(VoidType),\n    Declaration: v(Declaration),\n    VarDeclaration: v(VarDeclaration),\n    TypeDeclaration: v(TypeDeclaration),\n    ModuleDeclaration: v(ModuleDeclaration),\n    ModuleExportsDeclaration: v(ModuleExportsDeclaration),\n    ClassDeclaration: v(ClassDeclaration),\n    ParameterizedClassDeclaration: v(ParameterizedClassDeclaration),\n    ExtendsDeclaration: v(ExtendsDeclaration),\n  })\n}\n\nexport default globalContext;\n"],"names":["primitiveTypes","makeJSONError","validation","hasErrors","input","context","errors","path","message","expectedType","expected","toString","actual","typeOf","resolvePath","field","stringifyPath","concat","pointer","join","push","cyclicValidation","WeakMap","cyclicToString","WeakSet","inValidationCycle","type","tracked","get","weakSetHas","e","startValidationCycle","set","endValidationCycle","inToStringCycle","has","startToStringCycle","add","endToStringCycle","delete","weakset","value","weakSetAdd","weakSetDelete","validIdentifierOrAccessor","Validation","prefix","cyclic","candidate","matchPath","length","didClear","error","parts","Array","i","part","test","String","subject","undefined","Map","RuntimeTypeError","options","name","assign","TypeError","delimiter","makeTypeError","collected","actualType","actualAsString","makeString","trim","isArray","constructor","Object","JSON","stringify","makeError","validate","compareTypes","a","b","result","TypeAlias","TypeParameter","TypeParameterApplication","TypeTDZ","unwrap","compareWith","FlowIntoType","AnyType","ExistentialType","MixedType","Type","typeName","Error","captureStackTrace","assert","errorMessages","getErrorMessage","key","params","replace","m","TupleType","types","checkPredicate","accepts","inputTypes","isGreater","ArrayType","inCycle","startCycle","elementType","endCycle","output","BooleanLiteralType","BooleanType","EmptyType","typeInstances","parent","inner","hasProperty","getProperty","items","typeInstance","addConstraints","constraints","collectConstraintErrors","constraint","violation","constraintsAccept","hasConstraints","target","withDeclaration","properties","FlowIntoSymbol","Symbol","boundOrDefault","bound","default","recorded","withBinding","id","defaultType","flowIntoTypeParameter","typeParameter","existing","hasError","union","toJSON","FunctionTypeRestParam","FunctionTypeParam","optional","FunctionTypeReturn","ParentSymbol","NameRegistrySymbol","ModuleRegistrySymbol","CurrentModuleSymbol","TypeConstructorRegistrySymbol","InferrerSymbol","TypeSymbol","TypeParametersSymbol","TypePredicateRegistrySymbol","FunctionType","annotation","returnType","param","annotationParam","acceptsType","any","inputReturnType","returnTypeResult","inputParams","inputParam","rest","paramsLength","args","argsLength","empty","GeneratorType","isValid","next","return","throw","yieldType","nextType","warnedInstances","TypeConstructor","emitWarningMessage","GenericType","impl","getAnnotation","isPrototypeOf","invariant","NullLiteralType","VoidType","NullableType","ObjectTypeProperty","isStatic","static","targetPath","isNullable","existsOn","ObjectTypeIndexer","keyResult","valueResult","ObjectTypeCallProperty","Declaration","VarDeclaration","TypeDeclaration","typeAlias","addConstraint","apply","ModuleDeclaration","moduleExports","exporting","prop","declaration","declarations","moduleName","slice","innerContext","import","modules","body","module","indent","lines","split","ModuleExports","ClassDeclaration","shapeID","superClass","errorPath","errorMessage","propertyName","isSuperClassOf","current","superClassName","bodyProps","superProps","seen","seenStatic","props","PartialType","typeParameters","expand","ParameterizedClassDeclaration","getPartial","partial","bodyCreator","class","limit","Math","min","intersect","ExtendsDeclaration","ObjectType","indexers","callProperties","exact","property","getIndexer","newProp","hasIndexer","indexer","acceptsKey","hasCallProperties","acceptsCallProperties","collectErrorsWithIndexers","collectErrorsWithoutIndexers","collectErrorsExact","acceptsWithIndexers","acceptsWithoutIndexers","acceptsExact","compareTypeCallProperties","compareTypeWithIndexers","compareTypeWithoutIndexers","callProperty","inputCallProperties","identicalCount","j","inputCallProperty","loop","indexOf","acceptsValue","inputIndexers","inputProperties","inputProperty","inputIndexer","some","IntersectionType","object","getPropertyIndex","mergeProperties","source","typeProp","index","NumericLiteralType","NumberType","ParameterizedTypeAlias","identifier","typeCreator","ParameterizedFunctionType","acceptsParams","acceptsReturn","assertParams","assertReturn","function","RefinementType","StringLiteralType","StringType","SymbolLiteralType","SymbolType","ThisType","TypeBox","reveal","mixed","ref","warnedMissing","TypeReference","RevealedName","RevealedValue","getRevealed","container","UnionType","normalized","registerPrimitiveTypes","t","null","freeze","number","boolean","string","symbol","void","existential","registerBuiltinTypeConstructors","declareTypeConstructor","Date","isNaN","getTime","Promise","futureType","keyType","valueType","keyTypes","valueTypes","findKey","Set","registerTypePredicates","setPredicate","then","TypeInferer","primitive","inferPrimitive","inferred","inferComplex","inferFunction","inferObject","fromCharCode","fn","box","inferArray","inferDict","handler","getTypeConstructor","inferTypeParameters","inferInternal","numericIndexers","stringIndexers","values","item","inferredType","array","makeReactPropTypes","objectType","propName","componentName","makeWarningMessage","makeUnion","merged","mergeUnionTypes","aTypes","bTypes","bType","aType","makePropertyDescriptor","typeSource","descriptor","shouldAssert","augmentExistingAccessors","propertyToAccessor","makePropertyName","getClassName","resolveType","receiver","call","safeName","className","initializer","writable","config","propertyPath","check","defineProperty","warn","originalSetter","annotateValue","$DiffType","$FlowFixMeType","$KeysType","keys","literal","$ObjMapiType","mapper","applied","invoke","$ObjMapType","$PropertyType","unwrapped","$ShapeType","$SubType","$SuperType","$TupleMapType","tuple","$ValuesType","checkGenericType","checkType","ClassType","instanceType","warnedInvalidReferences","TypeContext","mode","TypeInferrer","Class","inferrer","infer","propertyNames","fromParent","global","getPredicate","predicate","Boolean","annotate","moduleRegistry","nameRegistry","var","head","handlerRegistry","instancePrototype","getPrototypeOf","parentPrototype","parentClass","typeParametersPointer","typeParam","createContext","currentModule","ModuleExportsDeclaration","tail","unshift","method","setProperty","tdz","from","clauses","pop","pattern","tests","clause","wrappedIterator","_$PropertyType","globalContext","__FLOW_RUNTIME_GLOBAL_CONTEXT_DO_NOT_USE_THIS_VARIABLE__","v","thing","defineProperties"],"mappings":"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"}