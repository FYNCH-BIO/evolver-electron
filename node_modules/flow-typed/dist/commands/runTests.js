'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.description = exports.name = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.setup = setup;
exports.run = run;

var _node = require('../lib/node.js');

var _fileUtils = require('../lib/fileUtils.js');

var _github = require('../lib/github.js');

var _libDefs = require('../lib/libDefs.js');

var _isInFlowTypedRepo = require('../lib/isInFlowTypedRepo');

var _isInFlowTypedRepo2 = _interopRequireDefault(_isInFlowTypedRepo);

var _flowVersion = require('../lib/flowVersion');

var _git = require('../lib/git');

var _got = require('got');

var _got2 = _interopRequireDefault(_got);

var _semver = require('semver');

var semver = _interopRequireWildcard(_semver);

var _unzipper = require('unzipper');

var unzip = _interopRequireWildcard(_unzipper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Used to decide which binary to fetch for each version of Flow
var BIN_PLATFORM = function (_) {
  switch (_node.os.type()) {
    case 'Linux':
      return 'linux64';
    case 'Darwin':
      return 'osx';
    case 'Windows_NT':
      return 'win64';

    default:
      throw new Error('Unsupported os.type()! ' + _node.os.type());
  }
}();
var PKG_ROOT_DIR = _node.path.join(__dirname, '..', '..');
var TEST_DIR = _node.path.join(PKG_ROOT_DIR, '.test-dir');
var BIN_DIR = _node.path.join(PKG_ROOT_DIR, '.flow-bins-cache');
var P = Promise;

/**
 * Scan the definitions/ directory to extract a flat list of TestGroup
 * structs. Each TestGroup represents a Package/PackageVersion/FlowVersion
 * directory.
 */
var basePathRegex = new RegExp('definitions/npm/(@[^/]*/)?[^/]*/?');
function getTestGroups(repoDirPath) {
  var onlyChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var libDefs, diff, changedDefs, baseDiff;
  return regeneratorRuntime.async(function getTestGroups$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _libDefs.getLibDefs)(repoDirPath));

        case 2:
          libDefs = _context.sent;

          if (!onlyChanged) {
            _context.next = 11;
            break;
          }

          _context.next = 6;
          return regeneratorRuntime.awrap((0, _git.getDiff)());

        case 6:
          diff = _context.sent;
          changedDefs = void 0;
          // $FlowFixMe

          baseDiff = diff.map(function (d) {
            var match = d.match(basePathRegex);
            if (match) {
              return match[0];
            }
          }).filter(function (d) {
            return d != null;
          });

          changedDefs = baseDiff.map(function (d) {
            return (0, _libDefs.parseRepoDirItem)(d).pkgName;
          });
          libDefs = libDefs.filter(function (def) {
            return changedDefs.includes(def.pkgName);
          });

        case 11:
          return _context.abrupt('return', libDefs.map(function (libDef) {
            var groupID = libDef.pkgName + '_' + libDef.pkgVersionStr + '/' + libDef.flowVersionStr;
            return {
              id: groupID,
              testFilePaths: libDef.testFilePaths,
              libDefPath: libDef.path,
              flowVersion: libDef.flowVersion
            };
          }));

        case 12:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this);
}

/**
 * Memoized function that queries the GitHub releases for Flow, downloads the
 * zip for each version, extracts the zip, and moves the binary to
 * TEST_BIN/flow-vXXX for use later when running tests.
 */
var _flowBinVersionPromise = null;
function getOrderedFlowBinVersions() {
  var numberOfReleases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;
  return regeneratorRuntime.async(function getOrderedFlowBinVersions$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(_flowBinVersionPromise !== null)) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt('return', _flowBinVersionPromise);

        case 2:
          return _context4.abrupt('return', _flowBinVersionPromise = function _callee2() {
            var _this = this;

            var IS_WINDOWS, GH_CLIENT, QUERY_PAGE_SIZE, OS_ARCH_FILTER_RE, page, apiPayload, flowBins;
            return regeneratorRuntime.async(function _callee2$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    console.log('Fetching all Flow binaries...');
                    IS_WINDOWS = _node.os.type() === 'Windows_NT';
                    GH_CLIENT = (0, _github.gitHubClient)();
                    // We only test against the latest numberOfReleases Versions

                    QUERY_PAGE_SIZE = numberOfReleases;
                    OS_ARCH_FILTER_RE = new RegExp('flow-' + BIN_PLATFORM);
                    page = 0;
                    _context3.next = 8;
                    return regeneratorRuntime.awrap(GH_CLIENT.repos.getReleases({
                      owner: 'facebook',
                      repo: 'flow',
                      page: page++,
                      per_page: QUERY_PAGE_SIZE
                    }));

                  case 8:
                    apiPayload = _context3.sent;
                    flowBins = apiPayload.data.filter(function (rel) {
                      // Temporary fix for https://github.com/facebook/flow/issues/5922
                      if (rel.tag_name === 'v0.67.0') {
                        console.log('==========================================================================================');
                        console.log('We are tempoarily skipping v0.67.0 due to https://github.com/facebook/flow/issues/5922');
                        console.log('==========================================================================================');
                        return false;
                      }

                      // Temporary fix for https://github.com/flowtype/flow-typed/issues/2422
                      if (rel.tag_name === 'v0.63.0') {
                        console.log('==========================================================================================');
                        console.log('We are tempoarily skipping v0.63.0 due to https://github.com/flowtype/flow-typed/issues/2422');
                        console.log('==========================================================================================');
                        return false;
                      }

                      // We only test against versions since 0.15.0 because it has proper
                      // [ignore] fixes (which are necessary to run tests)
                      // Because Windows was only supported starting with version 0.30.0, we also skip version prior to that when running on windows.
                      if (semver.lt(rel.tag_name, IS_WINDOWS ? '0.30.0' : '0.15.0')) {
                        return false;
                      }

                      // Because flow 0.57 was broken before 0.57.3 on the Windows platform, we also skip those versions when running on windows.
                      if (IS_WINDOWS && (semver.eq(rel.tag_name, '0.57.0') || semver.eq(rel.tag_name, '0.57.1') || semver.eq(rel.tag_name, '0.57.2'))) {
                        return false;
                      }
                      return true;
                    }).map(function (rel) {
                      // Find the binary zip in the list of assets
                      var binZip = rel.assets.filter(function (_ref) {
                        var name = _ref.name;

                        return OS_ARCH_FILTER_RE.test(name) && !/-latest.zip$/.test(name);
                      }).map(function (asset) {
                        return asset.browser_download_url;
                      });

                      if (binZip.length !== 1) {
                        throw new Error('Unexpected number of ' + BIN_PLATFORM + ' assets for flow-' + rel.tag_name + '! ' + JSON.stringify(binZip));
                      } else {
                        var version = rel.tag_name[0] === 'v' ? rel.tag_name : 'v' + rel.tag_name;
                        return { version: version, binURL: binZip[0] };
                      }
                    }).sort(function (a, b) {
                      return semver.lt(a.version, b.version) ? -1 : 1;
                    });
                    _context3.next = 12;
                    return regeneratorRuntime.awrap(P.all(flowBins.map(function _callee(_ref2) {
                      var version = _ref2.version,
                          binURL = _ref2.binURL;
                      var zipPath, binPath, flowBinDirPath;
                      return regeneratorRuntime.async(function _callee$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              zipPath = _node.path.join(BIN_DIR, 'flow-' + version + '.zip');
                              binPath = _node.path.join(BIN_DIR, 'flow-' + version + (IS_WINDOWS ? '.exe' : ''));
                              _context2.next = 4;
                              return regeneratorRuntime.awrap(_node.fs.exists(binPath));

                            case 4:
                              if (!_context2.sent) {
                                _context2.next = 6;
                                break;
                              }

                              return _context2.abrupt('return');

                            case 6:
                              _context2.next = 8;
                              return regeneratorRuntime.awrap(new Promise(function (res, rej) {
                                console.log('  Fetching flow-%s...', version);
                                _got2.default.stream(binURL, {
                                  headers: {
                                    'User-Agent': 'flow-typed Test Runner ' + '(github.com/flowtype/flow-typed)'
                                  }
                                }).on('error', function (err) {
                                  return rej(err);
                                }).pipe(_node.fs.createWriteStream(zipPath).on('close', function () {
                                  console.log('    flow-%s finished downloading.', version);
                                  res();
                                }));
                              }));

                            case 8:

                              // Extract the flow binary
                              flowBinDirPath = _node.path.join(BIN_DIR, 'TMP-flow-' + version);
                              _context2.next = 11;
                              return regeneratorRuntime.awrap(_node.fs.mkdir(flowBinDirPath));

                            case 11:
                              console.log('  Extracting flow-%s...', version);
                              _context2.next = 14;
                              return regeneratorRuntime.awrap(new Promise(function (res, rej) {
                                var unzipExtractor = unzip.Extract({ path: flowBinDirPath });
                                unzipExtractor.on('error', function (err) {
                                  rej(err);
                                });
                                unzipExtractor.on('close', function () {
                                  res();
                                });
                                _node.fs.createReadStream(zipPath).pipe(unzipExtractor);
                              }));

                            case 14:
                              if (!IS_WINDOWS) {
                                _context2.next = 19;
                                break;
                              }

                              _context2.next = 17;
                              return regeneratorRuntime.awrap(_node.fs.rename(_node.path.join(flowBinDirPath, 'flow', 'flow.exe'), _node.path.join(BIN_DIR, 'flow-' + version + '.exe')));

                            case 17:
                              _context2.next = 23;
                              break;

                            case 19:
                              _context2.next = 21;
                              return regeneratorRuntime.awrap(_node.fs.rename(_node.path.join(flowBinDirPath, 'flow', 'flow'), _node.path.join(BIN_DIR, 'flow-' + version)));

                            case 21:
                              _context2.next = 23;
                              return regeneratorRuntime.awrap(_node.child_process.execP(['chmod', '755', _node.path.join(BIN_DIR, 'flow-' + version)].join(' ')));

                            case 23:

                              console.log('  Removing flow-%s artifacts...', version);
                              _context2.next = 26;
                              return regeneratorRuntime.awrap(P.all([(0, _fileUtils.recursiveRmdir)(flowBinDirPath), _node.fs.unlink(zipPath)]));

                            case 26:
                              console.log('    flow-%s complete!', version);

                            case 27:
                            case 'end':
                              return _context2.stop();
                          }
                        }
                      }, null, _this);
                    })));

                  case 12:

                    console.log('Finished fetching Flow binaries.\n');

                    return _context3.abrupt('return', flowBins.map(function (bin) {
                      return bin.version;
                    }));

                  case 14:
                  case 'end':
                    return _context3.stop();
                }
              }
            }, null, this);
          }());

        case 3:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
}

var flowNameRegex = /^flow-v[0-9]+.[0-9]+.[0-9]+(\.exe)?$/;
/**
 * flow filename should be `flow-vx.x.x`
 * @param {string} name
 */
function checkFlowFilename(name) {
  return flowNameRegex.test(name);
}

/**
 * Return the sorted list of cached flow binaries that have previously been retrieved from github
 * and cached in the `.flow-bins-cache` directory.  This function is usually called when a failure
 * has occurred when attempting to refresh the flow releases from github, i.e. offline or over
 * API limit.
 */
function getCachedFlowBinVersions() {
  var numberOfReleases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 15;
  var versions;
  return regeneratorRuntime.async(function getCachedFlowBinVersions$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return regeneratorRuntime.awrap(_node.fs.readdir(_node.path.join(BIN_DIR)));

        case 2:
          _context5.t0 = checkFlowFilename;

          _context5.t1 = function (dir) {
            return dir.slice(6);
          };

          versions = _context5.sent.filter(_context5.t0).map(_context5.t1);


          // sort the versions that we have inplace
          versions.sort(function (a, b) {
            return semver.lt(a, b) ? -1 : 1;
          });

          versions.splice(0, versions.length - numberOfReleases);

          // return the versions with a leading 'v' to satisfy the expected return value
          return _context5.abrupt('return', versions.map(function (version) {
            return 'v' + version;
          }));

        case 8:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
}

function writeFlowConfig(repoDirPath, testDirPath, libDefPath, includeWarnings) {
  var destFlowConfigPath, flowConfigData;
  return regeneratorRuntime.async(function writeFlowConfig$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          destFlowConfigPath = _node.path.join(testDirPath, '.flowconfig');
          flowConfigData = ['[libs]', _node.path.basename(libDefPath), _node.path.join(repoDirPath, '..', '__util__', 'tdd_framework.js'), '', '[options]', 'suppress_comment=\\\\(.\\\\|\\n\\\\)*\\\\$ExpectError', includeWarnings ? 'include_warnings=true' : '', '',

          // Be sure to ignore stuff in the node_modules directory of the flow-typed
          // CLI repository!
          '[ignore]', _node.path.join(testDirPath, '..', '..', 'node_modules')].join('\n');
          _context6.next = 4;
          return regeneratorRuntime.awrap(_node.fs.writeFile(destFlowConfigPath, flowConfigData));

        case 4:
        case 'end':
          return _context6.stop();
      }
    }
  }, null, this);
}

function testTypeDefinition(flowVer, testDirPath) {
  return new Promise(function (res) {
    var child = _node.child_process.exec([_node.path.join(BIN_DIR, 'flow-' + flowVer), 'check', '--strip-root', '--all', testDirPath].join(' '));

    var stdErrOut = '';
    child.stdout.on('data', function (data) {
      return stdErrOut += data;
    });
    child.stderr.on('data', function (data) {
      return stdErrOut += data;
    });

    child.on('error', function (execError) {
      res({ stdErrOut: stdErrOut, errCode: null, execError: execError });
    });

    child.on('close', function (errCode) {
      res({ stdErrOut: stdErrOut, errCode: errCode, execError: null });
    });
  });
}

function runFlowTypeDefTests(flowVersionsToRun, groupId, testDirPath) {
  var _this2 = this;

  var errors, testBatch;
  return regeneratorRuntime.async(function runFlowTypeDefTests$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          errors = [];

        case 1:
          if (!(flowVersionsToRun.length > 0)) {
            _context8.next = 7;
            break;
          }

          // Run tests in batches to avoid saturation
          testBatch = flowVersionsToRun.slice(0, Math.min(flowVersionsToRun.length, 5)).map(function (group) {
            return flowVersionsToRun.shift(), group;
          });
          _context8.next = 5;
          return regeneratorRuntime.awrap(P.all(testBatch.map(function _callee3(flowVer) {
            var testRunId, _ref3, stdErrOut, errCode, execError;

            return regeneratorRuntime.async(function _callee3$(_context7) {
              while (1) {
                switch (_context7.prev = _context7.next) {
                  case 0:
                    testRunId = groupId + ' (flow-' + flowVer + ')';


                    console.log('Testing %s...', testRunId);

                    _context7.next = 4;
                    return regeneratorRuntime.awrap(testTypeDefinition(flowVer, testDirPath));

                  case 4:
                    _ref3 = _context7.sent;
                    stdErrOut = _ref3.stdErrOut;
                    errCode = _ref3.errCode;
                    execError = _ref3.execError;


                    if (execError !== null) {
                      errors.push(testRunId + ': Error executing Flow process: ' + execError.stack);
                    } else if (!stdErrOut.endsWith('Found 0 errors\n')) {
                      errors.push(testRunId + ': Unexpected Flow errors(' + String(errCode) + '):\n' + stdErrOut + '\n' + String(execError));
                    }

                  case 9:
                  case 'end':
                    return _context7.stop();
                }
              }
            }, null, _this2);
          })));

        case 5:
          _context8.next = 1;
          break;

        case 7:
          return _context8.abrupt('return', errors);

        case 8:
        case 'end':
          return _context8.stop();
      }
    }
  }, null, this);
}

function testLowestCapableFlowVersion(lowerVersions, testDirPath, lowestFlowVersionRan) {
  var _this3 = this;

  var lowerFlowVersionsToRun, lowestCapableFlowVersion, lowerTestBatch;
  return regeneratorRuntime.async(function testLowestCapableFlowVersion$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          lowerFlowVersionsToRun = lowerVersions;
          lowestCapableFlowVersion = lowestFlowVersionRan;

        case 2:
          if (!(lowerFlowVersionsToRun.length > 0)) {
            _context10.next = 8;
            break;
          }

          lowerTestBatch = lowerFlowVersionsToRun.slice(0, Math.min(lowerFlowVersionsToRun.length, 5)).map(function (group) {
            return lowerFlowVersionsToRun.shift(), group;
          });
          _context10.next = 6;
          return regeneratorRuntime.awrap(P.all(lowerTestBatch.map(function _callee4(flowVer) {
            var _ref4, stdErrOut, execError;

            return regeneratorRuntime.async(function _callee4$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return regeneratorRuntime.awrap(testTypeDefinition(flowVer, testDirPath));

                  case 2:
                    _ref4 = _context9.sent;
                    stdErrOut = _ref4.stdErrOut;
                    execError = _ref4.execError;


                    if (execError !== null || !stdErrOut.endsWith('Found 0 errors\n')) {
                      lowerFlowVersionsToRun = [];
                    } else {
                      lowestCapableFlowVersion = semver.lt(lowestCapableFlowVersion, flowVer) ? lowestCapableFlowVersion : flowVer;
                    }

                  case 6:
                  case 'end':
                    return _context9.stop();
                }
              }
            }, null, _this3);
          })));

        case 6:
          _context10.next = 2;
          break;

        case 8:
          return _context10.abrupt('return', lowestCapableFlowVersion);

        case 9:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, this);
}

function findLowestCapableFlowVersion(repoDirPath, orderedFlowVersions, lowestFlowVersionRan, testDirPath, libDefPath) {
  var lowerFlowVersionsToRun, lowerLowVersions, higherLowVersions, lowestOfHigherVersions;
  return regeneratorRuntime.async(function findLowestCapableFlowVersion$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          lowerFlowVersionsToRun = orderedFlowVersions.filter(function (flowVer) {
            return semver.lt(flowVer, lowestFlowVersionRan);
          });

          lowerFlowVersionsToRun.reverse();
          lowerLowVersions = lowerFlowVersionsToRun.filter(function (flowVer) {
            return semver.lt(flowVer, '0.53.0');
          });
          higherLowVersions = lowerFlowVersionsToRun.filter(function (flowVer) {
            return semver.gte(flowVer, '0.53.0');
          });
          _context11.next = 6;
          return regeneratorRuntime.awrap(writeFlowConfig(repoDirPath, testDirPath, libDefPath, true));

        case 6:
          _context11.next = 8;
          return regeneratorRuntime.awrap(testLowestCapableFlowVersion(higherLowVersions, testDirPath, lowestFlowVersionRan));

        case 8:
          lowestOfHigherVersions = _context11.sent;
          _context11.next = 11;
          return regeneratorRuntime.awrap(writeFlowConfig(repoDirPath, testDirPath, libDefPath, false));

        case 11:
          _context11.next = 13;
          return regeneratorRuntime.awrap(testLowestCapableFlowVersion(lowerLowVersions, testDirPath, lowestOfHigherVersions));

        case 13:
          return _context11.abrupt('return', _context11.sent);

        case 14:
        case 'end':
          return _context11.stop();
      }
    }
  }, null, this);
}

/**
 * Remove all files except flow instances
 */
function removeTrashFromBinDir() {
  var _this4 = this;

  return regeneratorRuntime.async(function removeTrashFromBinDir$(_context13) {
    while (1) {
      switch (_context13.prev = _context13.next) {
        case 0:
          _context13.next = 2;
          return regeneratorRuntime.awrap(_node.fs.readdir(_node.path.join(BIN_DIR)));

        case 2:
          _context13.t0 = function (name) {
            return !checkFlowFilename(name);
          };

          _context13.t1 = function _callee5(el) {
            return regeneratorRuntime.async(function _callee5$(_context12) {
              while (1) {
                switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return regeneratorRuntime.awrap(_node.fs.unlink(_node.path.resolve(BIN_DIR, el)));

                  case 2:
                  case 'end':
                    return _context12.stop();
                }
              }
            }, null, _this4);
          };

          _context13.sent.filter(_context13.t0).forEach(_context13.t1);

        case 5:
        case 'end':
          return _context13.stop();
      }
    }
  }, null, this);
}

/**
 * Given a TestGroup structure determine all versions of Flow that match the
 * FlowVersion specification and, for each, run `flow check` on the test
 * directory.
 */
function runTestGroup(repoDirPath, testGroup, orderedFlowVersions) {
  var _this5 = this;

  var errors, testDirName, testDirPath, destLibDefPath, copiedFileNames, testGrpFlowSemVerRange, flowVersionsToRun, lowestFlowVersionRan, lowerVersions, higherVersions, lowerVersionErrors, higherVersionErrors, lowestCapableFlowVersion;
  return regeneratorRuntime.async(function runTestGroup$(_context15) {
    while (1) {
      switch (_context15.prev = _context15.next) {
        case 0:
          errors = [];
          // Some older versions of Flow choke on ">"/"<"/"="

          testDirName = testGroup.id.replace(/\//g, '--').replace(/>/g, 'gt').replace(/</g, 'lt').replace(/=/g, 'eq');
          testDirPath = _node.path.join(TEST_DIR, testDirName);
          _context15.next = 5;
          return regeneratorRuntime.awrap(_node.fs.exists(testDirPath));

        case 5:
          if (!_context15.sent) {
            _context15.next = 7;
            break;
          }

          throw new Error('Trying to run ' + testGroup.id + ', but test dir already exists! I\'m' + 'confused... Bailing out!');

        case 7:
          _context15.next = 9;
          return regeneratorRuntime.awrap(_node.fs.exists(BIN_DIR));

        case 9:
          if (_context15.sent) {
            _context15.next = 12;
            break;
          }

          _context15.next = 12;
          return regeneratorRuntime.awrap(_node.fs.mkdir(BIN_DIR));

        case 12:
          _context15.prev = 12;
          _context15.next = 15;
          return regeneratorRuntime.awrap(_node.fs.mkdir(testDirPath));

        case 15:

          // Copy files into the test dir
          destLibDefPath = _node.path.join(testDirPath, _node.path.basename(testGroup.libDefPath));
          copiedFileNames = new Set();
          _context15.next = 19;
          return regeneratorRuntime.awrap(P.all([P.all(testGroup.testFilePaths.map(function _callee6(filePath, idx) {
            var fileName, destBasename;
            return regeneratorRuntime.async(function _callee6$(_context14) {
              while (1) {
                switch (_context14.prev = _context14.next) {
                  case 0:
                    // Because there could be multiple test files with the same basename,
                    // we disambiguate each one with a locally-unique index.
                    //
                    // i.e. underscore/v1.x.x/test-underscore.js
                    //      underscore/v1.x.x/flow-v0.22.x/test-underscore.js
                    //
                    // Only mangles the name when there's a naming collision. Otherwise, uses the original.
                    fileName = _node.path.basename(filePath);
                    destBasename = copiedFileNames.has(fileName) ? idx + '-' + fileName : fileName;

                    copiedFileNames.add(destBasename);
                    _context14.next = 5;
                    return regeneratorRuntime.awrap((0, _fileUtils.copyFile)(filePath, _node.path.join(testDirPath, destBasename)));

                  case 5:
                  case 'end':
                    return _context14.stop();
                }
              }
            }, null, _this5);
          })), (0, _fileUtils.copyFile)(testGroup.libDefPath, destLibDefPath)]));

        case 19:

          // For each compatible version of Flow, run `flow check` and verify there
          // are no errors.
          testGrpFlowSemVerRange = (0, _flowVersion.toSemverString)(testGroup.flowVersion);
          flowVersionsToRun = orderedFlowVersions.filter(function (flowVer) {
            return semver.satisfies(flowVer, testGrpFlowSemVerRange);
          });

          // Windows hasn't flow < 30.0 but we have tests for flow < 30.0. We need skip it. Example: redux_v3

          if (flowVersionsToRun.length) {
            _context15.next = 23;
            break;
          }

          return _context15.abrupt('return', []);

        case 23:
          lowestFlowVersionRan = flowVersionsToRun[0];
          lowerVersions = flowVersionsToRun.filter(function (flowVer) {
            return semver.lt(flowVer, '0.53.0');
          });
          higherVersions = flowVersionsToRun.filter(function (flowVer) {
            return semver.gte(flowVer, '0.53.0');
          });
          _context15.next = 28;
          return regeneratorRuntime.awrap(writeFlowConfig(repoDirPath, testDirPath, testGroup.libDefPath, false));

        case 28:
          _context15.next = 30;
          return regeneratorRuntime.awrap(runFlowTypeDefTests(lowerVersions, testGroup.id, testDirPath));

        case 30:
          lowerVersionErrors = _context15.sent;
          _context15.next = 33;
          return regeneratorRuntime.awrap(writeFlowConfig(repoDirPath, testDirPath, testGroup.libDefPath, true));

        case 33:
          _context15.next = 35;
          return regeneratorRuntime.awrap(runFlowTypeDefTests(higherVersions, testGroup.id, testDirPath));

        case 35:
          higherVersionErrors = _context15.sent;


          errors.push.apply(errors, _toConsumableArray(higherVersionErrors).concat(_toConsumableArray(lowerVersionErrors)));
          _context15.next = 39;
          return regeneratorRuntime.awrap(findLowestCapableFlowVersion(repoDirPath, orderedFlowVersions, lowestFlowVersionRan, testDirPath, testGroup.libDefPath));

        case 39:
          lowestCapableFlowVersion = _context15.sent;


          if (lowestCapableFlowVersion !== lowestFlowVersionRan) {
            console.log('Tests for ' + testGroup.id + ' ran successfully on flow ' + lowestCapableFlowVersion + '.\n        Consider setting ' + lowestCapableFlowVersion + ' as the lower bound!');
          }

          return _context15.abrupt('return', errors);

        case 42:
          _context15.prev = 42;
          _context15.next = 45;
          return regeneratorRuntime.awrap(_node.fs.exists(testDirPath));

        case 45:
          if (!_context15.sent) {
            _context15.next = 48;
            break;
          }

          _context15.next = 48;
          return regeneratorRuntime.awrap((0, _fileUtils.recursiveRmdir)(testDirPath));

        case 48:
          return _context15.finish(42);

        case 49:
        case 'end':
          return _context15.stop();
      }
    }
  }, null, this, [[12,, 42, 49]]);
}

function runTests(repoDirPath, testPatterns, onlyChanged, numberOfFlowVersions) {
  var testPatternRes, testGroups, results, testGroup, orderedFlowVersions, testGroupErrors;
  return regeneratorRuntime.async(function runTests$(_context16) {
    while (1) {
      switch (_context16.prev = _context16.next) {
        case 0:
          testPatternRes = testPatterns.map(function (patt) {
            return new RegExp(patt, 'g');
          });
          _context16.next = 3;
          return regeneratorRuntime.awrap(getTestGroups(repoDirPath, onlyChanged));

        case 3:
          _context16.t0 = function (testGroup) {
            if (testPatternRes.length === 0) {
              return true;
            }

            for (var i = 0; i < testPatternRes.length; i++) {
              var pattern = testPatternRes[i];
              if (testGroup.id.match(pattern) != null) {
                return true;
              }
            }

            return false;
          };

          testGroups = _context16.sent.filter(_context16.t0);
          _context16.prev = 5;
          _context16.next = 8;
          return regeneratorRuntime.awrap(_node.fs.exists(TEST_DIR));

        case 8:
          if (!_context16.sent) {
            _context16.next = 11;
            break;
          }

          _context16.next = 11;
          return regeneratorRuntime.awrap((0, _fileUtils.recursiveRmdir)(TEST_DIR));

        case 11:
          _context16.next = 13;
          return regeneratorRuntime.awrap(_node.fs.mkdir(TEST_DIR));

        case 13:
          results = new Map();

        case 14:
          if (!(testGroups.length > 0)) {
            _context16.next = 36;
            break;
          }

          testGroup = testGroups.shift();
          //Prepare bin folder to collect flow instances

          _context16.next = 18;
          return regeneratorRuntime.awrap(removeTrashFromBinDir());

        case 18:
          orderedFlowVersions = void 0;
          _context16.prev = 19;
          _context16.next = 22;
          return regeneratorRuntime.awrap(getOrderedFlowBinVersions(numberOfFlowVersions));

        case 22:
          orderedFlowVersions = _context16.sent;
          _context16.next = 30;
          break;

        case 25:
          _context16.prev = 25;
          _context16.t1 = _context16['catch'](19);
          _context16.next = 29;
          return regeneratorRuntime.awrap(getCachedFlowBinVersions(numberOfFlowVersions));

        case 29:
          orderedFlowVersions = _context16.sent;

        case 30:
          _context16.next = 32;
          return regeneratorRuntime.awrap(runTestGroup(repoDirPath, testGroup, orderedFlowVersions));

        case 32:
          testGroupErrors = _context16.sent;

          if (testGroupErrors.length > 0) {
            (function () {
              var errors = results.get(testGroup.id) || [];
              testGroupErrors.forEach(function (err) {
                return errors.push(err);
              });
              results.set(testGroup.id, errors);
            })();
          }
          _context16.next = 14;
          break;

        case 36:
          return _context16.abrupt('return', results);

        case 37:
          _context16.prev = 37;
          _context16.next = 40;
          return regeneratorRuntime.awrap(_node.fs.exists(TEST_DIR));

        case 40:
          if (!_context16.sent) {
            _context16.next = 43;
            break;
          }

          _context16.next = 43;
          return regeneratorRuntime.awrap((0, _fileUtils.recursiveRmdir)(TEST_DIR));

        case 43:
          return _context16.finish(37);

        case 44:
        case 'end':
          return _context16.stop();
      }
    }
  }, null, this, [[5,, 37, 44], [19, 25]]);
}

var name = exports.name = 'run-tests';
var description = exports.description = 'Run definition tests for library definitions in the flow-typed project';

function setup(yargs) {
  return yargs.usage('$0 ' + name + ' - ' + description).options({
    path: {
      describe: 'Override default path for libdef root (Mainly for testing purposes)',
      type: 'string',
      demand: false
    },
    onlyChanged: {
      type: 'boolean',
      description: 'Run only changed definition tests',
      demand: false
    },
    numberOfFlowVersions: {
      type: 'number',
      description: 'Only run against the latest X versions of flow',
      demand: false
    }
  });
}

function run(argv) {
  var testPatterns, onlyChanged, numberOfFlowVersions, cwd, basePath, cwdDefsNPMPath, repoDirPath, results;
  return regeneratorRuntime.async(function run$(_context17) {
    while (1) {
      switch (_context17.prev = _context17.next) {
        case 0:
          if ((0, _isInFlowTypedRepo2.default)()) {
            _context17.next = 3;
            break;
          }

          console.log('This command only works in a clone of flowtype/flow-typed. ' + 'It is a tool used to run tests of the library definitions in the flow-typed project.');
          return _context17.abrupt('return', 1);

        case 3:
          testPatterns = argv._.slice(1);
          onlyChanged = Boolean(argv.onlyChanged);
          numberOfFlowVersions = Number(argv.numberOfFlowVersions) || 15;
          cwd = process.cwd();
          basePath = argv.path ? String(argv.path) : cwd;
          cwdDefsNPMPath = _node.path.join(basePath, 'definitions', 'npm');
          _context17.next = 11;
          return regeneratorRuntime.awrap(_node.fs.exists(cwdDefsNPMPath));

        case 11:
          if (!_context17.sent) {
            _context17.next = 15;
            break;
          }

          _context17.t0 = cwdDefsNPMPath;
          _context17.next = 16;
          break;

        case 15:
          _context17.t0 = _node.path.join(__dirname, '..', '..', '..', 'definitions', 'npm');

        case 16:
          repoDirPath = _context17.t0;


          if (onlyChanged) {
            console.log('Running changed definition tests against latest %s flow versions in %s...\n', numberOfFlowVersions, repoDirPath);
          } else {
            console.log('Running definition tests against latest %s flow versions in %s...\n', numberOfFlowVersions, repoDirPath);
          }

          _context17.next = 20;
          return regeneratorRuntime.awrap(runTests(repoDirPath, testPatterns, onlyChanged, numberOfFlowVersions));

        case 20:
          results = _context17.sent;

          console.log(' ');
          Array.from(results).forEach(function (_ref5) {
            var _ref6 = _slicedToArray(_ref5, 2),
                testGroupName = _ref6[0],
                errors = _ref6[1];

            console.log('ERROR: %s', testGroupName);
            errors.forEach(function (err) {
              return console.log(' * %s\n', err.split('\n').map(function (line, idx) {
                return idx === 0 ? line : '   ' + line;
              }).join('\n'));
            });
          });

          if (!(results.size === 0)) {
            _context17.next = 26;
            break;
          }

          console.log('All tests passed!');
          return _context17.abrupt('return', 0);

        case 26:
          return _context17.abrupt('return', 1);

        case 27:
        case 'end':
          return _context17.stop();
      }
    }
  }, null, this);
}