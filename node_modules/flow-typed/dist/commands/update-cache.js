'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.description = exports.name = undefined;
exports.setup = setup;
exports.run = run;

var _cacheRepoUtils = require('../lib/cacheRepoUtils');

var _node = require('../lib/node');

var name = exports.name = 'update-cache';

var description = exports.description = 'Update the flow-typed definitions cache';

function setup(yargs) {
  return yargs.usage('$0 ' + name + ' - ' + description).options({
    cacheDir: {
      alias: 'c',
      describe: 'Directory (absolute or relative path, ~ is not supported) to store cache of libdefs',
      type: 'string',
      demand: false
    }
  });
}

function run(args) {
  var _cacheDir;

  return regeneratorRuntime.async(function run$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;

          if (args.cacheDir) {
            _cacheDir = _node.path.resolve(args.cacheDir);

            console.log('â€¢ Setting cache dir', _cacheDir);
            (0, _cacheRepoUtils._setCustomCacheDir)(_cacheDir);
          }

          console.log('Updating flow-typed definitions...');
          _context.next = 5;
          return regeneratorRuntime.awrap((0, _cacheRepoUtils.ensureCacheRepo)());

        case 5:

          console.log('Definitions update successful!');
          return _context.abrupt('return', 0);

        case 9:
          _context.prev = 9;
          _context.t0 = _context['catch'](0);

          console.error('Update failed: ' + _context.t0.message);

          return _context.abrupt('return', 1);

        case 13:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this, [[0, 9]]);
}