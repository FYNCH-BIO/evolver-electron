'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._setCustomCacheDir = exports._REMOTE_REPO_URL = exports._getLastUpdatedFile = exports._getCacheRepoGitDir = exports._clearCustomCacheDir = exports._cacheRepoEnsureToken = exports._CACHE_REPO_EXPIRY = undefined;
exports.ensureCacheRepo = ensureCacheRepo;
exports.getCacheRepoDir = getCacheRepoDir;
exports.verifyCLIVersion = verifyCLIVersion;

var _fileUtils = require('./fileUtils');

var _git = require('./git');

var _node = require('./node');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CACHE_REPO_EXPIRY = 1000 * 60; // 1 minute
var REMOTE_REPO_URL = 'https://github.com/flowtype/flow-typed.git';

function cloneCacheRepo() {
  return regeneratorRuntime.async(function cloneCacheRepo$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap((0, _fileUtils.mkdirp)(getCacheRepoDir()));

        case 2:
          _context.prev = 2;
          _context.next = 5;
          return regeneratorRuntime.awrap((0, _git.cloneInto)(REMOTE_REPO_URL, getCacheRepoDir()));

        case 5:
          _context.next = 11;
          break;

        case 7:
          _context.prev = 7;
          _context.t0 = _context['catch'](2);

          console.error('ERROR: Unable to clone local cache repo!');
          throw _context.t0;

        case 11:
          _context.next = 13;
          return regeneratorRuntime.awrap(_node.fs.writeFile(getLastUpdatedFile(), String(Date.now())));

        case 13:
        case 'end':
          return _context.stop();
      }
    }
  }, null, this, [[2, 7]]);
}

var customCacheDir = null;
function getCacheDir() {
  return customCacheDir === null ? _node.path.join(_node.os.homedir(), '.flow-typed') : customCacheDir;
}
function clearCustomCacheDir() {
  customCacheDir = null;
}
function setCustomCacheDir(dir) {
  customCacheDir = dir;
}

function getCacheRepoGitDir() {
  return _node.path.join(getCacheRepoDir(), '.git');
}

function getLastUpdatedFile() {
  return _node.path.join(getCacheRepoDir(), 'lastUpdated');
}

function rebaseCacheRepo() {
  return regeneratorRuntime.async(function rebaseCacheRepo$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return regeneratorRuntime.awrap(_node.fs.exists(getCacheRepoDir()));

        case 2:
          _context2.t0 = _context2.sent;

          if (!_context2.t0) {
            _context2.next = 7;
            break;
          }

          _context2.next = 6;
          return regeneratorRuntime.awrap(_node.fs.exists(getCacheRepoGitDir()));

        case 6:
          _context2.t0 = _context2.sent;

        case 7:
          if (!_context2.t0) {
            _context2.next = 22;
            break;
          }

          _context2.prev = 8;
          _context2.next = 11;
          return regeneratorRuntime.awrap((0, _git.rebaseRepoMaster)(getCacheRepoDir()));

        case 11:
          _context2.next = 17;
          break;

        case 13:
          _context2.prev = 13;
          _context2.t1 = _context2['catch'](8);

          console.error('ERROR: Unable to rebase the local cache repo. ' + _context2.t1.message);
          return _context2.abrupt('return', false);

        case 17:
          _context2.next = 19;
          return regeneratorRuntime.awrap(_node.fs.writeFile(getLastUpdatedFile(), String(Date.now())));

        case 19:
          return _context2.abrupt('return', true);

        case 22:
          _context2.next = 24;
          return regeneratorRuntime.awrap(cloneCacheRepo());

        case 24:
          return _context2.abrupt('return', true);

        case 25:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this, [[8, 13]]);
}

/**
 * Ensure that the CACHE_REPO_DIR exists and is recently rebased.
 * (else: create/rebase it)
 */
var cacheRepoEnsureToken = {
  lastEnsured: 0,
  pendingEnsurance: Promise.resolve()
};
function ensureCacheRepo() {
  var cacheRepoExpiry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CACHE_REPO_EXPIRY;
  var prevEnsurance;
  return regeneratorRuntime.async(function ensureCacheRepo$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          if (!(cacheRepoEnsureToken.lastEnsured + 5 * 1000 * 60 >= Date.now())) {
            _context4.next = 2;
            break;
          }

          return _context4.abrupt('return', cacheRepoEnsureToken.pendingEnsurance);

        case 2:

          cacheRepoEnsureToken.lastEnsured = Date.now();
          prevEnsurance = cacheRepoEnsureToken.pendingEnsurance;
          return _context4.abrupt('return', cacheRepoEnsureToken.pendingEnsurance = prevEnsurance.then(function () {
            return function _callee() {
              var repoDirExists, repoGitDirExists, lastUpdated, lastUpdatedRaw, lastUpdatedNum, rebaseSuccessful;
              return regeneratorRuntime.async(function _callee$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      repoDirExists = _node.fs.exists(getCacheRepoDir());
                      repoGitDirExists = _node.fs.exists(getCacheRepoGitDir());
                      _context3.next = 4;
                      return regeneratorRuntime.awrap(repoDirExists);

                    case 4:
                      _context3.t0 = !_context3.sent;

                      if (_context3.t0) {
                        _context3.next = 9;
                        break;
                      }

                      _context3.next = 8;
                      return regeneratorRuntime.awrap(repoGitDirExists);

                    case 8:
                      _context3.t0 = !_context3.sent;

                    case 9:
                      if (!_context3.t0) {
                        _context3.next = 15;
                        break;
                      }

                      console.log('\u2022 flow-typed cache not found, fetching from GitHub...');
                      _context3.next = 13;
                      return regeneratorRuntime.awrap(cloneCacheRepo());

                    case 13:
                      _context3.next = 30;
                      break;

                    case 15:
                      lastUpdated = 0;
                      _context3.next = 18;
                      return regeneratorRuntime.awrap(_node.fs.exists(getLastUpdatedFile()));

                    case 18:
                      if (!_context3.sent) {
                        _context3.next = 24;
                        break;
                      }

                      _context3.next = 21;
                      return regeneratorRuntime.awrap(_node.fs.readFile(getLastUpdatedFile()));

                    case 21:
                      lastUpdatedRaw = _context3.sent;
                      lastUpdatedNum = parseInt(lastUpdatedRaw, 10);

                      if (String(lastUpdatedNum) === String(lastUpdatedRaw)) {
                        lastUpdated = lastUpdatedNum;
                      }

                    case 24:
                      if (!(lastUpdated + cacheRepoExpiry < Date.now())) {
                        _context3.next = 30;
                        break;
                      }

                      console.log('â€¢ rebasing flow-typed cache...');
                      _context3.next = 28;
                      return regeneratorRuntime.awrap(rebaseCacheRepo());

                    case 28:
                      rebaseSuccessful = _context3.sent;

                      if (!rebaseSuccessful) {
                        console.log("\nNOTE: Unable to rebase local cache! If you don't currently " + "have internet connectivity, no worries -- we'll update the " + 'local cache the next time you do.\n');
                      }

                    case 30:
                    case 'end':
                      return _context3.stop();
                  }
                }
              }, null, this);
            }();
          }));

        case 5:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
}

function getCacheRepoDir() {
  return _node.path.join(getCacheDir(), 'repo');
}

function verifyCLIVersion() {
  var metadataPath, metadata, compatibleCLIRange, thisCLIPkgJsonPath, thisCLIPkgJson, thisCLIVersion;
  return regeneratorRuntime.async(function verifyCLIVersion$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          metadataPath = _node.path.join(getCacheRepoDir(), 'definitions', '.cli-metadata.json');
          _context5.t0 = JSON;
          _context5.t1 = String;
          _context5.next = 5;
          return regeneratorRuntime.awrap(_node.fs.readFile(metadataPath));

        case 5:
          _context5.t2 = _context5.sent;
          _context5.t3 = (0, _context5.t1)(_context5.t2);
          metadata = _context5.t0.parse.call(_context5.t0, _context5.t3);
          compatibleCLIRange = metadata.compatibleCLIRange;

          if (compatibleCLIRange) {
            _context5.next = 11;
            break;
          }

          throw new Error('Unable to find the \'compatibleCLIRange\' property in ' + metadataPath + '. ' + 'You might need to update your flow-typed CLI to the latest version.');

        case 11:
          thisCLIPkgJsonPath = _node.path.join(__dirname, '..', '..', 'package.json');
          _context5.t4 = JSON;
          _context5.t5 = String;
          _context5.next = 16;
          return regeneratorRuntime.awrap(_node.fs.readFile(thisCLIPkgJsonPath));

        case 16:
          _context5.t6 = _context5.sent;
          _context5.t7 = (0, _context5.t5)(_context5.t6);
          thisCLIPkgJson = _context5.t4.parse.call(_context5.t4, _context5.t7);
          thisCLIVersion = thisCLIPkgJson.version;

          if (_semver2.default.satisfies(thisCLIVersion, compatibleCLIRange)) {
            _context5.next = 22;
            break;
          }

          throw new Error('Please upgrade your flow-typed CLI! This CLI is version ' + (thisCLIVersion + ', but the latest flow-typed definitions are only ') + ('compatible with flow-typed@' + compatibleCLIRange));

        case 22:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
}

exports._CACHE_REPO_EXPIRY = CACHE_REPO_EXPIRY;
exports._cacheRepoEnsureToken = cacheRepoEnsureToken;
exports._clearCustomCacheDir = clearCustomCacheDir;
exports._getCacheRepoGitDir = getCacheRepoGitDir;
exports._getLastUpdatedFile = getLastUpdatedFile;
exports._REMOTE_REPO_URL = REMOTE_REPO_URL;
exports._setCustomCacheDir = setCustomCacheDir;