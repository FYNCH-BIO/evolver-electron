'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._validateVersionPart = exports._validateVersionNumPart = exports._parsePkgNameVer = exports._extractLibDefsFromNpmPkgDir = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.findNpmLibDef = findNpmLibDef;
exports.getInstalledNpmLibDefs = getInstalledNpmLibDefs;
exports.getNpmLibDefs = getNpmLibDefs;
exports.getNpmLibDefVersionHash = getNpmLibDefVersionHash;
exports.getScopedPackageName = getScopedPackageName;

var _cacheRepoUtils = require('../cacheRepoUtils');

var _codeSign = require('../codeSign');

var _fileUtils = require('../fileUtils');

var _flowVersion2 = require('../flowVersion');

var _git = require('../git');

var _node = require('../node');

var _semver = require('../semver');

var _semver2 = require('semver');

var _semver3 = _interopRequireDefault(_semver2);

var _got = require('got');

var _got2 = _interopRequireDefault(_got);

var _validationErrors = require('../validationErrors');

var _libDefs = require('../libDefs');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var P = Promise;

function extractLibDefsFromNpmPkgDir(pkgDirPath, scope, pkgNameVer, validationErrors, validating) {
  var _this = this;

  var errContext, parsedPkgNameVer, pkgName, pkgVersion, npmDefsDirPath, pkgVersionStr, libDefFileName, pkgDirItems, fullPkgName, commonTestFiles, parsedFlowDirs, libDefs;
  return regeneratorRuntime.async(function extractLibDefsFromNpmPkgDir$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          errContext = 'npm/' + (scope === null ? '' : scope + '/') + pkgNameVer;
          parsedPkgNameVer = parsePkgNameVer(pkgNameVer, errContext, validationErrors);

          if (!(parsedPkgNameVer === null)) {
            _context2.next = 4;
            break;
          }

          return _context2.abrupt('return', []);

        case 4:
          pkgName = parsedPkgNameVer.pkgName, pkgVersion = parsedPkgNameVer.pkgVersion;
          npmDefsDirPath = scope === null ? _node.path.resolve(pkgDirPath, '..') : _node.path.resolve(pkgDirPath, '..', '..');
          pkgVersionStr = (0, _semver.versionToString)(pkgVersion);
          libDefFileName = pkgName + '_' + pkgVersionStr + '.js';
          _context2.next = 10;
          return regeneratorRuntime.awrap(_node.fs.readdir(pkgDirPath));

        case 10:
          pkgDirItems = _context2.sent;

          if (!validating) {
            _context2.next = 15;
            break;
          }

          fullPkgName = '' + (scope === null ? '' : scope + '/') + pkgName;
          _context2.next = 15;
          return regeneratorRuntime.awrap(_npmExists(fullPkgName).then().catch(function (error) {
            // Only fail spen on 404, not on timeout
            if (error.statusCode === 404) {
              var pkgError = 'Package does not exist on npm!';
              (0, _validationErrors.validationError)(fullPkgName, pkgError, validationErrors);
            }
          }));

        case 15:
          commonTestFiles = [];
          parsedFlowDirs = [];

          pkgDirItems.forEach(function (pkgDirItem) {
            var pkgDirItemPath = _node.path.join(pkgDirPath, pkgDirItem);
            var pkgDirItemContext = _node.path.relative(npmDefsDirPath, pkgDirItemPath);

            var pkgDirItemStat = _node.fs.statSync(pkgDirItemPath);
            if (pkgDirItemStat.isFile()) {
              var isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(pkgDirItem);
              if (isValidTestFile) commonTestFiles.push(pkgDirItemPath);
            } else if (pkgDirItemStat.isDirectory()) {
              var errCount = validationErrors == null ? 0 : validationErrors.size;
              var parsedFlowDir = (0, _flowVersion2.parseDirString)(pkgDirItem, pkgNameVer + '/' + pkgDirItem, validationErrors);
              // If parsing a flow directory incurred a validation error, don't keep it
              // around in our list of parsed flow directories
              // TODO: Make the parseFlowDirString API return `null` when there's an
              //       error
              if (validationErrors != null && errCount !== validationErrors.size) {
                return;
              }
              parsedFlowDirs.push([pkgDirItemPath, parsedFlowDir]);
            } else {
              var error = 'Unexpected directory item';
              (0, _validationErrors.validationError)(pkgDirItemContext, error, validationErrors);
            }
          });

          if (!(0, _flowVersion2.disjointVersionsAll)(parsedFlowDirs.map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                _ = _ref2[0],
                ver = _ref2[1];

            return ver;
          }))) {
            (0, _validationErrors.validationError)(errContext, 'Flow versions not disjoint!', validationErrors);
          }

          if (parsedFlowDirs.length === 0) {
            (0, _validationErrors.validationError)(errContext, 'No libdef files found!', validationErrors);
          }

          libDefs = [];
          _context2.next = 23;
          return regeneratorRuntime.awrap(P.all(parsedFlowDirs.map(function _callee(_ref3) {
            var _ref4 = _slicedToArray(_ref3, 2),
                flowDirPath = _ref4[0],
                flowVersion = _ref4[1];

            var testFilePaths, libDefFilePath, error;
            return regeneratorRuntime.async(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    testFilePaths = [].concat(commonTestFiles);
                    libDefFilePath = null;
                    _context.next = 4;
                    return regeneratorRuntime.awrap(_node.fs.readdir(flowDirPath));

                  case 4:
                    _context.t0 = function (flowDirItem) {
                      var flowDirItemPath = _node.path.join(flowDirPath, flowDirItem);
                      var flowDirItemContext = _node.path.relative(npmDefsDirPath, flowDirItemPath);
                      var flowDirItemStat = _node.fs.statSync(flowDirItemPath);
                      if (flowDirItemStat.isFile()) {
                        if (_node.path.extname(flowDirItem) === '.swp') {
                          return;
                        }

                        // Is this the libdef file?
                        if (flowDirItem === libDefFileName) {
                          libDefFilePath = _node.path.join(flowDirPath, flowDirItem);
                          return;
                        }

                        // Is this a test file?
                        var isValidTestFile = _libDefs.TEST_FILE_NAME_RE.test(flowDirItem);

                        if (isValidTestFile) {
                          testFilePaths.push(flowDirItemPath);
                          return;
                        }

                        var error = 'Unexpected file. This directory can only contain test files ' + ('or a libdef file named ' + ('`' + libDefFileName + '`') + '.');
                        (0, _validationErrors.validationError)(flowDirItemContext, error, validationErrors);
                      } else {
                        var _error = 'Unexpected sub-directory. This directory can only contain test ' + ('files or a libdef file named ' + ('`' + libDefFileName + '`') + '.');
                        (0, _validationErrors.validationError)(flowDirItemContext, _error, validationErrors);
                      }
                    };

                    _context.sent.forEach(_context.t0);

                    if (!(libDefFilePath === null)) {
                      _context.next = 11;
                      break;
                    }

                    libDefFilePath = _node.path.join(flowDirPath, libDefFileName);
                    error = 'No libdef file found. Looking for a file named ' + libDefFileName;

                    (0, _validationErrors.validationError)(flowDirPath, error, validationErrors);
                    return _context.abrupt('return');

                  case 11:

                    libDefs.push({
                      scope: scope,
                      name: pkgName,
                      version: pkgVersionStr,
                      flowVersion: flowVersion,
                      path: libDefFilePath,
                      testFilePaths: testFilePaths
                    });

                  case 12:
                  case 'end':
                    return _context.stop();
                }
              }
            }, null, _this);
          })));

        case 23:
          return _context2.abrupt('return', libDefs);

        case 24:
        case 'end':
          return _context2.stop();
      }
    }
  }, null, this);
}

function getCacheNpmLibDefs() {
  return regeneratorRuntime.async(function getCacheNpmLibDefs$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          _context3.next = 2;
          return regeneratorRuntime.awrap((0, _cacheRepoUtils.ensureCacheRepo)());

        case 2:
          _context3.next = 4;
          return regeneratorRuntime.awrap((0, _cacheRepoUtils.verifyCLIVersion)());

        case 4:
          return _context3.abrupt('return', getNpmLibDefs(_node.path.join((0, _cacheRepoUtils.getCacheRepoDir)(), 'definitions')));

        case 5:
        case 'end':
          return _context3.stop();
      }
    }
  }, null, this);
}

var PKG_NAMEVER_RE = /^(.*)_v\^?([0-9]+)\.([0-9]+|x)\.([0-9]+|x)(-.*)?$/;
function parsePkgNameVer(pkgNameVer, errContext, validationErrors) {
  var pkgNameVerMatches = pkgNameVer.match(PKG_NAMEVER_RE);
  if (pkgNameVerMatches == null) {
    var error = 'Malformed npm package name! ' + 'Expected the name to be formatted as <PKGNAME>_v<MAJOR>.<MINOR>.<PATCH>';
    (0, _validationErrors.validationError)(pkgNameVer, error, validationErrors);
    return null;
  }

  var _pkgNameVerMatches = _slicedToArray(pkgNameVerMatches, 6),
      _ = _pkgNameVerMatches[0],
      pkgName = _pkgNameVerMatches[1],
      major = _pkgNameVerMatches[2],
      minor = _pkgNameVerMatches[3],
      patch = _pkgNameVerMatches[4],
      prerel = _pkgNameVerMatches[5];

  major = validateVersionNumPart(major, 'major', errContext, validationErrors);
  minor = validateVersionPart(minor, 'minor', errContext, validationErrors);
  patch = validateVersionPart(patch, 'patch', errContext, validationErrors);

  if (prerel != null) {
    prerel = prerel.substr(1);
  }

  return { pkgName: pkgName, pkgVersion: { major: major, minor: minor, patch: patch, prerel: prerel } };
}

/**
 * Given a number-or-wildcard part of a version string (i.e. a `minor` or
 * `patch` part), parse the string into either a number or 'x'.
 */
function validateVersionPart(part, partName, context, validationErrs) {
  if (part === 'x') {
    return part;
  }
  return validateVersionNumPart(part, partName, context, validationErrs);
}

/**
 * Given a number-only part of a version string (i.e. the `major` part), parse
 * the string into a number.
 */
function validateVersionNumPart(part, partName, context, validationErrs) {
  var num = parseInt(part, 10);
  if (String(num) !== part) {
    var error = 'Invalid ' + partName + ' number: \'' + part + '\'. Expected a number.';
    (0, _validationErrors.validationError)(context, error, validationErrs);
    return -1;
  }
  return num;
}

function pkgVersionMatch(pkgSemver, libDefSemverRaw) {
  // The package version should be treated as a semver implicitly prefixed by a
  // `^`. (i.e.: "foo_v2.2.x" is the same range as "^2.2.x")
  // UNLESS it is prefixed by the equals character (i.e. "foo_=v2.2.x")
  var libDefSemver = libDefSemverRaw[0] !== '=' && libDefSemverRaw[0] !== '^' ? '^' + libDefSemverRaw : libDefSemverRaw;

  if (_semver3.default.valid(pkgSemver)) {
    // Test the single package version against the LibDef range
    return _semver3.default.satisfies(pkgSemver, libDefSemver);
  }

  if (_semver3.default.valid(libDefSemver)) {
    // Test the single LibDef version against the package range
    return _semver3.default.satisfies(libDefSemver, pkgSemver);
  }

  if (!(_semver3.default.validRange(pkgSemver) && _semver3.default.validRange(libDefSemver))) {
    return false;
  }

  var pkgRange = new _semver3.default.Range(pkgSemver);
  var libDefRange = new _semver3.default.Range(libDefSemver);

  if (libDefRange.set[0].length !== 2) {
    throw new Error('Invalid npm libdef version! It appears to be a non-continugous range.');
  }

  var libDefLower = (0, _semver.getRangeLowerBound)(libDefRange);
  var libDefUpper = (0, _semver.getRangeUpperBound)(libDefRange);

  var pkgBelowLower = _semver3.default.gtr(libDefLower, pkgSemver);
  var pkgAboveUpper = _semver3.default.ltr(libDefUpper, pkgSemver);
  if (pkgBelowLower || pkgAboveUpper) {
    return false;
  }

  var pkgLower = pkgRange.set[0][0].semver.version;
  return libDefRange.test(pkgLower);
}

function filterLibDefs(defs, filter) {
  return defs.filter(function (def) {
    var filterMatch = false;
    switch (filter.type) {
      case 'exact':
        var fullName = def.scope ? def.scope + '/' + def.name : def.name;
        filterMatch = filter.pkgName.toLowerCase() === fullName.toLowerCase() && pkgVersionMatch(filter.pkgVersion, def.version);
        break;
      default:
        filter;
    }
    if (!filterMatch) {
      return false;
    }

    var filterFlowVersion = filter.flowVersion;
    if (filterFlowVersion !== undefined) {
      var _flowVersion = def.flowVersion;

      switch (_flowVersion.kind) {
        case 'all':
          return true;
        case 'ranged':
        case 'specific':
          return _semver3.default.satisfies((0, _flowVersion2.toSemverString)(filterFlowVersion), (0, _flowVersion2.toSemverString)(def.flowVersion));
        default:
          _flowVersion;
      }
    }

    return true;
  }).sort(function (a, b) {
    var aZeroed = a.version.replace(/x/g, '0');
    var bZeroed = b.version.replace(/x/g, '0');
    return _semver3.default.gt(aZeroed, bZeroed) ? -1 : 1;
  });
}

function _npmExists(pkgName) {
  var pkgUrl;
  return regeneratorRuntime.async(function _npmExists$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          pkgUrl = 'https://www.npmjs.com/package/' + pkgName;
          return _context4.abrupt('return', (0, _got2.default)(pkgUrl, { method: 'HEAD' }));

        case 2:
        case 'end':
          return _context4.stop();
      }
    }
  }, null, this);
}

function findNpmLibDef(pkgName, pkgVersion, flowVersion) {
  var libDefs, filteredLibDefs;
  return regeneratorRuntime.async(function findNpmLibDef$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return regeneratorRuntime.awrap(getCacheNpmLibDefs());

        case 2:
          libDefs = _context5.sent;
          filteredLibDefs = filterLibDefs(libDefs, {
            type: 'exact',
            pkgName: pkgName,
            pkgVersion: pkgVersion,
            flowVersion: flowVersion
          });
          return _context5.abrupt('return', filteredLibDefs.length === 0 ? null : filteredLibDefs[0]);

        case 5:
        case 'end':
          return _context5.stop();
      }
    }
  }, null, this);
}

function getInstalledNpmLibDefs(flowProjectRootDir, libdefDir) {
  var _this2 = this;

  var typedefDir, libDefDirPath, installedLibDefs, filesInNpmDir;
  return regeneratorRuntime.async(function getInstalledNpmLibDefs$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          typedefDir = libdefDir || 'flow-typed';
          libDefDirPath = _node.path.join(flowProjectRootDir, typedefDir, 'npm');
          installedLibDefs = new Map();
          _context7.next = 5;
          return regeneratorRuntime.awrap(_node.fs.exists(libDefDirPath));

        case 5:
          if (!_context7.sent) {
            _context7.next = 11;
            break;
          }

          _context7.next = 8;
          return regeneratorRuntime.awrap((0, _fileUtils.getFilesInDir)(libDefDirPath, true));

        case 8:
          filesInNpmDir = _context7.sent;
          _context7.next = 11;
          return regeneratorRuntime.awrap(P.all([].concat(_toConsumableArray(filesInNpmDir)).map(function _callee2(fileName) {
            var fullFilePath, terseFilePath, fileStat, fileContent, signedCodeVer, matches, _scope, nameVer, pkgNameVer, _pkgName, _pkgVersion, flowVerMatches, flowVerStr, flowDirStr, context, flowVer;

            return regeneratorRuntime.async(function _callee2$(_context6) {
              while (1) {
                switch (_context6.prev = _context6.next) {
                  case 0:
                    fullFilePath = _node.path.join(libDefDirPath, fileName);
                    terseFilePath = _node.path.relative(flowProjectRootDir, fullFilePath);
                    _context6.next = 4;
                    return regeneratorRuntime.awrap(_node.fs.stat(fullFilePath));

                  case 4:
                    fileStat = _context6.sent;

                    if (!fileStat.isFile()) {
                      _context6.next = 33;
                      break;
                    }

                    _context6.next = 8;
                    return regeneratorRuntime.awrap(_node.fs.readFile(fullFilePath));

                  case 8:
                    fileContent = _context6.sent.toString();

                    if (!(0, _codeSign.verifySignedCode)(fileContent)) {
                      _context6.next = 33;
                      break;
                    }

                    signedCodeVer = (0, _codeSign.getSignedCodeVersion)(fileContent);

                    if (!(signedCodeVer === null)) {
                      _context6.next = 13;
                      break;
                    }

                    return _context6.abrupt('return');

                  case 13:
                    matches = signedCodeVer.match(/([^\/]+)\/(@[^\/]+\/)?([^\/]+)\/([^\/]+)/);

                    if (!(matches == null)) {
                      _context6.next = 16;
                      break;
                    }

                    return _context6.abrupt('return');

                  case 16:
                    if (!(matches[1] === '<<STUB>>')) {
                      _context6.next = 19;
                      break;
                    }

                    installedLibDefs.set(terseFilePath, {
                      kind: 'Stub',
                      name: matches[2]
                    });
                    return _context6.abrupt('return');

                  case 19:
                    _scope = matches[2] == null ? null : matches[2].substr(0, matches[2].length - 1);
                    nameVer = matches[3];

                    if (!(nameVer === null)) {
                      _context6.next = 23;
                      break;
                    }

                    return _context6.abrupt('return');

                  case 23:
                    pkgNameVer = parsePkgNameVer(nameVer, '', new Map());

                    if (!(pkgNameVer === null)) {
                      _context6.next = 26;
                      break;
                    }

                    return _context6.abrupt('return');

                  case 26:
                    _pkgName = pkgNameVer.pkgName, _pkgVersion = pkgNameVer.pkgVersion;
                    flowVerMatches = matches[4].match(/^flow_(>=|<=)?(v[^ ]+) ?(<=(v.+))?$/);
                    flowVerStr = flowVerMatches == null ? matches[3] : flowVerMatches[3] == null ? flowVerMatches[2] : flowVerMatches[2] + '-' + flowVerMatches[4];
                    flowDirStr = 'flow_' + flowVerStr;
                    context = nameVer + '/' + flowDirStr;
                    flowVer = flowVerMatches == null ? (0, _flowVersion2.parseDirString)(flowDirStr, context) : (0, _flowVersion2.parseDirString)(flowDirStr, context);


                    installedLibDefs.set(terseFilePath, {
                      kind: 'LibDef',
                      libDef: {
                        scope: _scope,
                        name: _pkgName,
                        version: (0, _semver.versionToString)(_pkgVersion),
                        flowVersion: flowVer,
                        path: terseFilePath,
                        testFilePaths: []
                      }
                    });

                  case 33:
                  case 'end':
                    return _context6.stop();
                }
              }
            }, null, _this2);
          })));

        case 11:
          return _context7.abrupt('return', installedLibDefs);

        case 12:
        case 'end':
          return _context7.stop();
      }
    }
  }, null, this);
}

/**
 * Retrieve a list of *all* npm libdefs.
 */
function getNpmLibDefs(defsDirPath, validationErrors, validating) {
  var _this3 = this;

  var npmLibDefs, npmDefsDirPath, dirItems;
  return regeneratorRuntime.async(function getNpmLibDefs$(_context10) {
    while (1) {
      switch (_context10.prev = _context10.next) {
        case 0:
          npmLibDefs = [];
          npmDefsDirPath = _node.path.join(defsDirPath, 'npm');
          _context10.next = 4;
          return regeneratorRuntime.awrap(_node.fs.readdir(npmDefsDirPath));

        case 4:
          dirItems = _context10.sent;
          _context10.next = 7;
          return regeneratorRuntime.awrap(P.all(dirItems.map(function _callee4(itemName) {
            var itemPath, itemStat, _scope2, scopeDirItems, libDefs, error;

            return regeneratorRuntime.async(function _callee4$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    itemPath = _node.path.join(npmDefsDirPath, itemName);
                    _context9.next = 3;
                    return regeneratorRuntime.awrap(_node.fs.stat(itemPath));

                  case 3:
                    itemStat = _context9.sent;

                    if (!itemStat.isDirectory()) {
                      _context9.next = 20;
                      break;
                    }

                    if (!(itemName[0] === '@')) {
                      _context9.next = 14;
                      break;
                    }

                    // This must be a scoped npm package, so go one directory deeper
                    _scope2 = itemName;
                    _context9.next = 9;
                    return regeneratorRuntime.awrap(_node.fs.readdir(itemPath));

                  case 9:
                    scopeDirItems = _context9.sent;
                    _context9.next = 12;
                    return regeneratorRuntime.awrap(P.all(scopeDirItems.map(function _callee3(itemName) {
                      var itemPath, itemStat, libDefs, error;
                      return regeneratorRuntime.async(function _callee3$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              itemPath = _node.path.join(npmDefsDirPath, _scope2, itemName);
                              _context8.next = 3;
                              return regeneratorRuntime.awrap(_node.fs.stat(itemPath));

                            case 3:
                              itemStat = _context8.sent;

                              if (!itemStat.isDirectory()) {
                                _context8.next = 11;
                                break;
                              }

                              _context8.next = 7;
                              return regeneratorRuntime.awrap(extractLibDefsFromNpmPkgDir(itemPath, _scope2, itemName, validationErrors, validating));

                            case 7:
                              libDefs = _context8.sent;

                              libDefs.forEach(function (libDef) {
                                return npmLibDefs.push(libDef);
                              });
                              _context8.next = 13;
                              break;

                            case 11:
                              error = 'Expected only sub-directories in this dir!';

                              (0, _validationErrors.validationError)(itemPath, error, validationErrors);

                            case 13:
                            case 'end':
                              return _context8.stop();
                          }
                        }
                      }, null, _this3);
                    })));

                  case 12:
                    _context9.next = 18;
                    break;

                  case 14:
                    _context9.next = 16;
                    return regeneratorRuntime.awrap(extractLibDefsFromNpmPkgDir(itemPath, null, // No scope
                    itemName, validationErrors, validating));

                  case 16:
                    libDefs = _context9.sent;

                    libDefs.forEach(function (libDef) {
                      return npmLibDefs.push(libDef);
                    });

                  case 18:
                    _context9.next = 22;
                    break;

                  case 20:
                    error = 'Expected only directories to be present in this directory.';

                    (0, _validationErrors.validationError)(itemPath, error, validationErrors);

                  case 22:
                  case 'end':
                    return _context9.stop();
                }
              }
            }, null, _this3);
          })));

        case 7:
          return _context10.abrupt('return', npmLibDefs);

        case 8:
        case 'end':
          return _context10.stop();
      }
    }
  }, null, this);
}

function getNpmLibDefVersionHash(repoDirPath, libDef) {
  var latestCommitHash;
  return regeneratorRuntime.async(function getNpmLibDefVersionHash$(_context11) {
    while (1) {
      switch (_context11.prev = _context11.next) {
        case 0:
          _context11.next = 2;
          return regeneratorRuntime.awrap((0, _git.findLatestFileCommitHash)(repoDirPath, _node.path.relative(repoDirPath, libDef.path)));

        case 2:
          latestCommitHash = _context11.sent;
          return _context11.abrupt('return', latestCommitHash.substr(0, 10) + '/' + (libDef.scope === null ? '' : libDef.scope + '/') + (libDef.name + '_' + libDef.version + '/') + ('flow_' + (0, _flowVersion2.toSemverString)(libDef.flowVersion)));

        case 4:
        case 'end':
          return _context11.stop();
      }
    }
  }, null, this);
}

function getScopedPackageName(libDef) {
  return (libDef.scope === null ? '' : libDef.scope + '/') + ('' + libDef.name);
}

exports._extractLibDefsFromNpmPkgDir = extractLibDefsFromNpmPkgDir;
exports._parsePkgNameVer = parsePkgNameVer;
exports._validateVersionNumPart = validateVersionNumPart;
exports._validateVersionPart = validateVersionPart;