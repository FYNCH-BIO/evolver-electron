'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = parseFlowConfig;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var KNOWN_REGEXPS = {
  ignore: true,
  options: {
    'suppress_comment': true,
    'module.name_mapper': true
  }
};

var KNOWN_BOOLEANS = {
  options: {
    'munge_underscores': true,
    'use_strict': true,
    'strip_root': true
  }
};

var KNOWN_NUMERICS = {
  options: {
    'server.max_workers': true,
    'traces': true
  }
};

/**
 * Parse a given flow configuration (supplied as a string), and return the parsed representation.
 */
function parseFlowConfig(input) {
  var projectRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();

  var lines = input.split(/(\r?\n)+/).map(function (line) {
    return line.trim();
  }).filter(function (line) {
    return line.length > 0;
  });

  var structure = new FlowConfig();

  var section = void 0;
  var sectionName = void 0;

  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    if (line.charAt(0) === '#' || line.charAt(0) === ';') {
      // This is a comment.
      continue;
    }
    var matchSection = /^\[(.+)\](\s*#(.*))?$/.exec(line);
    if (matchSection) {
      sectionName = matchSection[1].trim();
      section = [];
      structure[sectionName] = section;
    } else if (!section || !sectionName) {
      throw new Error('Invalid flow configuration, found entry outside of a named section.');
    } else if (KNOWN_REGEXPS[sectionName] === true) {
      section.push(regexpify(line));
    } else {
      var matchesKeyValue = /^([A-Za-z0-9_\.]+)=(.*)$/.exec(line);
      if (matchesKeyValue) {
        var key = matchesKeyValue[1];
        var value = matchesKeyValue[2];
        if (KNOWN_REGEXPS[sectionName] && KNOWN_REGEXPS[sectionName][key]) {
          var matchesMapper = /^\s*'(.*)'\s*->\s*'(.*)'$/.exec(value);
          if (matchesMapper) {
            value = [regexpify(matchesMapper[1]), matchesMapper[2]];
          } else {
            value = regexpify(value);
          }
        } else if (KNOWN_BOOLEANS[sectionName] && KNOWN_BOOLEANS[sectionName][key]) {
          value = value === 'true' ? true : false;
        } else if (KNOWN_NUMERICS[sectionName] && KNOWN_NUMERICS[sectionName][key]) {
          value = Number(value);
        } else {
          var _matchesMapper = /^\s*'(.*)'\s*->\s*'(.*)'$/.exec(value);
          if (_matchesMapper) {
            value = [_matchesMapper[1], _matchesMapper[2].replace(/<PROJECT_ROOT>/g, projectRoot)];
          }
        }
        section.push([key, value]);
      } else {
        section.push(line);
      }
    }
  }

  return structure;
}

function regexpify(input) {
  var projectRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();

  return new RegExp(input.replace(/\\([\(\|\)])/g, function (a, b) {
    return b;
  }).replace(/<PROJECT_ROOT>/g, projectRoot).replace(/\//g, '\\/'));
}

var FlowConfig = exports.FlowConfig = function () {
  function FlowConfig() {
    _classCallCheck(this, FlowConfig);

    this.ignore = [];
    this.include = [];
    this.lib = [];
    this.options = [];
    this.version = [];
  }

  _createClass(FlowConfig, [{
    key: 'ignoresFile',
    value: function ignoresFile(filename) {
      var ignore = this.ignore;
      var length = ignore.length;

      for (var i = 0; i < length; i++) {
        var pattern = ignore[i];
        if (pattern.test(filename)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'suppressesType',
    value: function suppressesType(name) {
      var options = this.options;
      var length = options.length;

      for (var i = 0; i < length; i++) {
        var _options$i = _slicedToArray(options[i], 2),
            key = _options$i[0],
            value = _options$i[1];

        if (key === 'suppress_type' && name === value) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'suppressesComment',
    value: function suppressesComment(comment) {
      var options = this.options;
      var length = options.length;

      for (var i = 0; i < length; i++) {
        var _options$i2 = _slicedToArray(options[i], 2),
            key = _options$i2[0],
            value = _options$i2[1];

        if (key === 'suppress_comment' && value.test(comment)) {
          return true;
        }
      }
      return false;
    }
  }, {
    key: 'remapModule',
    value: function remapModule(name) {
      var mappers = this.get('module.name_mapper');
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = mappers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _ref = _step.value;

          var _ref2 = _slicedToArray(_ref, 2);

          var pattern = _ref2[0];
          var redirect = _ref2[1];

          if (pattern.test(name)) {
            return redirect;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return name;
    }
  }, {
    key: 'get',
    value: function get(target) {
      var named = this[target];
      if (named !== null && (typeof named === 'undefined' ? 'undefined' : _typeof(named)) === 'object') {
        return named;
      }
      var options = this.options;
      var length = options.length;

      var result = [];
      for (var i = 0; i < length; i++) {
        var _options$i3 = _slicedToArray(options[i], 2),
            key = _options$i3[0],
            value = _options$i3[1];

        if (key === target) {
          if (KNOWN_BOOLEANS.options[key] || KNOWN_NUMERICS.options[key]) {
            return value;
          }
          result.push(value);
        }
      }
      return result;
    }
  }]);

  return FlowConfig;
}();